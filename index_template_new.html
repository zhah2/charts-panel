<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Research & Strategy Team Dashboard</title>
<style>
/* Base styles inspired by reference site */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: #F9FAFB; /* light gray background */
  margin: 0;
  padding: 0;
  color: #111827; /* dark gray text */
}

/* Header styling - move buttons to topbar level */
.topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 2rem;
  background-color: white;
  border-bottom: none;
}

.logo {
  height: 32px;
  margin-right: 1rem;
}

.title {
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.title-container {
  display: flex;
  align-items: center;
}

/* Tabs container with action buttons */
.tabs-container {
  position: relative;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: white;
  border-bottom: 1px solid #E5E7EB;
  padding: 0 2rem;
  height: 40px; /* Same height as tabs */
}

/* Tabs styling - updated to match image */
.tabs {
  display: flex;
  margin-left: 0; /* Align to left */
}

.tabs button {
  height: 40px;
  border: none;
  background: transparent;
  padding: 0 16px;
  font-weight: 500;
  cursor: pointer;
  color: #6B7280; /* gray-500 for inactive */
  transition: color 0.2s, border-bottom 0.2s;
  margin-right: 8px;
  border-bottom: 2px solid transparent;
}

.tabs button.active {
  color: #111827; /* Dark text for active tab */
  border-bottom: 2px solid #111827; /* Dark underline */
  font-weight: 600;
}

/* Main content layout */
main {
  display: flex;
  height: calc(100vh - 65px); /* Full height minus header */
}

/* Sidebar styles */
.sidebar {
  width: 200px; /* Narrower sidebar (reduced from 240px) */
  background-color: #F9FAFB;
  overflow-y: auto;
  padding: 1rem;
  border-right: 1px solid #E5E7EB;
}

.cat {
  margin-bottom: 0.5rem;
}

.cat-hdr {
  display: flex;
  align-items: center;
  padding: 0.3rem 0.25rem;
  cursor: pointer;
  font-weight: 600;
  font-size: 1rem;
  color: #111827; /* Darker category header */
  margin-bottom: 0.125rem;
  border-radius: 4px; /* Slightly rounded */
}

.cat-hdr:hover {
  background-color: #F3F4F6; /* gray-100 hover */
}

.category-title-row {
  display: flex;
  align-items: center;
}

/* Chevron styled */
.chevron {
  display: inline-flex;
  width: 14px;
  height: 20px;
  align-items: center;
  justify-content: center;
  margin-right: 8px;
  font-size: 14px;
  font-weight: bold;
  color: #374151; /* gray-700 */
  transition: transform 0.2s;
  font-family: sans-serif;
}

.chevron-expanded {
  transform: rotate(90deg);
}

.cat-body {
  padding-left: calc(1.5rem + 8px); /* Indent past chevron */
  margin-bottom: 0.75rem;
}

.cat-body label {
  display: flex;
  align-items: flex-start;
  padding: 0.2rem 0;
  margin-left: 0;
  font-size: 0.875rem;
  color: #374151;
}

.cat-body label input[type="checkbox"] {
  margin-right: 0.5rem;
  cursor: pointer;
  margin-top: 2px;
}

.select-all-label {
  display: flex;
  align-items: center;
  padding: 0.2rem 0;
  margin-left: 0;
  font-size: 0.875rem;
  color: #374151;
  font-weight: 500;
  margin-bottom: 0.4rem;
}

.select-all-label input[type="checkbox"] {
  margin-right: 0.5rem;
  cursor: pointer;
}

/* Improved checkbox and label styling for consistency */
input[type="checkbox"] {
  width: 16px !important;
  height: 16px !important;
  flex-shrink: 0 !important;
  margin: 0 8px 0 0 !important;
  cursor: pointer !important;
  display: inline-block !important;
  vertical-align: top !important;
  box-sizing: border-box !important;
  appearance: checkbox !important;
  -webkit-appearance: checkbox !important;
  -moz-appearance: checkbox !important;
}

/* Consistent label styling */
.cat-body label,
.select-all-label,
.label-with-count {
  display: flex !important;
  align-items: flex-start !important; 
  padding: 4px 0 !important;
  margin: 0 0 4px 0 !important;
  line-height: 1.2 !important;
  font-size: 0.875rem !important;
  color: #374151 !important;
}

/* Handle wrapping for long label text */
.label-text {
  display: inline-block !important;
  line-height: 1.2 !important;
  padding-top: 1px !important;
}

/* Container for label and checkbox */
.label-with-count > div {
  display: flex !important;
  align-items: flex-start !important;
  flex: 1 !important;
}

/* Label count styling */
.label-count {
  color: #6B7280 !important;
  font-size: 0.875rem !important;
  margin-left: 8px !important;
  flex-shrink: 0 !important;
  margin-top: 0 !important;
}

/* Chart grid area */
.grid {
  flex: 1;
  overflow-y: auto;
  padding: 12px; /* Further reduced padding (from 16px) */
  background-color: #F9FAFB;
}

/* Chart card styling */
.card {
  background-color: white;
  border-radius: 0.5rem;
  overflow: hidden; /* Crucial for containing children */
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06); /* Subtle shadow */
  display: flex;
  flex-direction: column;
  cursor: pointer; 
  position: relative; /* For absolute positioning of checkbox */
}

/* Card image container */
.card-image {
  width: 100%;
  height: 380px;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  padding: 0.5rem;
  box-sizing: border-box;
}

/* Specific styling for local images to ensure proper sizing */
.card-image img[src^="panel-charts/"] {
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

/* Ensure img/iframe fill the container correctly */
.card-image img, .card-image iframe {
  display: block; 
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  border: none;
  overflow: hidden;
}

/* Card labels styling */
.card-labels {
  padding: 0.5rem 1rem; /* Consistent padding */
  border-top: 1px solid #E5E7EB;
  color: #6B7280;
  font-size: 0.75rem;
  flex-shrink: 0; /* Prevent labels from shrinking */
  background-color: white; /* Ensure background */
}

/* Loading indicator */
.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  width: 100%;
  font-size: 1rem;
  color: #6B7280;
}

/* Grid layout for charts - 2 columns */
.charts-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px; /* Further reduced gap (from 20px) */
  width: 100%;
}

/* Empty state */
.empty-state {
    display: flex;
    justify-content: center;
    align-items: center;
    height: calc(100% - 48px); /* Account for padding */
    width: 100%;
    color: #6B7280;
    text-align: center;
    font-size: 1rem;
}

/* Style for empty tabs */
.empty-tab {
  width: 100%;
  height: calc(100vh - 110px);
  display: flex;
  justify-content: center;
  align-items: center;
}

.empty-tab .empty-state {
  font-size: 1.5rem;
  font-weight: 500;
  color: #4B5563;
}

/* Modal styles for zoom */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0s linear 0.3s;
}

.modal-overlay.visible {
  opacity: 1;
  visibility: visible;
  transition: opacity 0.3s ease, visibility 0s linear 0s;
}

.modal-content {
  background-color: white;
  padding: 2rem;
  border-radius: 8px;
  max-width: 95vw;
  max-height: 95vh;
  position: relative;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  transform: scale(0.95);
  transition: transform 0.3s ease;
  overflow: hidden;
}

.modal-overlay.visible .modal-content {
  transform: scale(1);
}

.modal-close {
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 2rem;
  font-weight: bold;
  color: #6B7280;
  background: none;
  border: none;
  cursor: pointer;
  line-height: 1;
  padding: 0.5rem;
}
.modal-close:hover {
    color: #111827;
}

.modal-image-container {
  width: 100%;
  height: calc(85vh - 4rem); /* Increased from 75vh to 85vh */
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 1rem;
}

.modal-image-container img, .modal-image-container iframe {
  display: block;
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  margin: 0 auto;
  object-fit: contain;
  overflow: hidden;
}

.modal-labels {
  text-align: center;
  font-size: 0.9rem;
  color: #6B7280;
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid #E5E7EB;
}

/* Chart selection checkbox */
.card {
  position: relative; /* For absolute positioning of checkbox */
}

/* Move chart checkbox to top-left */
.chart-checkbox-container {
  position: absolute;
  top: 5px;
  left: 5px;
  z-index: 10;
  opacity: 0;
  transition: opacity 0.2s;
  background-color: rgba(255, 255, 255, 0.8);
  border-radius: 4px;
  padding: 2px;
}

.card:hover .chart-checkbox-container {
  opacity: 1;
}

.chart-checkbox {
  width: 16px;
  height: 16px;
  cursor: pointer;
}

/* Selected chart indicator */
.card.selected {
  box-shadow: 0 0 0 2px #4F46E5, 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
}

/* Improve label count styling */
.label-with-count {
  display: flex;
  justify-content: space-between;
  width: 100%;
  align-items: flex-start;
}

.label-count {
  color: #6B7280;
  font-size: 0.875rem;
  margin-left: 8px;
  font-weight: normal;
}

/* Action buttons styling - move higher and fix icon */
.action-buttons {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: -10px; /* Move buttons 10px higher */
}

.action-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.375rem; /* rounded-md */
  font-size: 0.75rem; /* Smaller font size */
  font-weight: 500;
  height: 30px; /* Smaller height */
  padding: 0 0.75rem; /* Smaller padding */
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  background-color: white;
  color: #374151;
  transition: box-shadow 0.2s, background-color 0.2s;
  border: 1px solid #E5E7EB;
  cursor: pointer;
}

.action-button:hover {
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  background-color: #F3F4F6;
}

.action-button svg {
  margin-right: 0.25rem;
  height: 14px; /* Fixed size for icons */
  width: 14px;
  display: inline-block; /* Ensure proper display */
  vertical-align: middle; /* Better alignment */
}

/* Target tab styles */
.target-tab {
  width: 100%;
  height: 100%;
  overflow-y: auto;
  padding: 1.5rem;
  background-color: #F9FAFB;
}

.target-container {
  max-width: 1200px;
  margin: 0 auto;
}

.allocation-tabs {
  display: flex;
  border-bottom: 1px solid #E5E7EB;
  margin-bottom: 1.5rem;
  overflow-x: auto;
}

.allocation-tabs button {
  padding: 0.75rem 1rem;
  border: none;
  background: none;
  font-size: 0.9rem;
  color: #6B7280;
  cursor: pointer;
  white-space: nowrap;
  border-bottom: 2px solid transparent;
}

.allocation-tabs button.active {
  color: #111827;
  border-bottom-color: #111827;
  font-weight: 500;
}

.allocation-section, .time-series-section {
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.date-selector {
  margin-bottom: 1.5rem;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  padding: 1rem;
}

.date-selector h4 {
  margin-top: 0;
  margin-bottom: 1rem;
  font-size: 0.9rem;
  color: #6B7280;
}

.date-input-group {
  display: flex;
  gap: 0.5rem;
}

select {
  padding: 0.5rem;
  border: 1px solid #E5E7EB;
  border-radius: 0.25rem;
  font-size: 0.9rem;
}

.no-data-message {
  text-align: center;
  color: #6B7280;
  margin: 2rem 0;
  font-style: italic;
}

.allocation-line {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
}

.line-container {
  flex: 1;
  position: relative;
}

.asset-label {
  width: 120px;
  text-align: right;
  padding-right: 1rem;
  font-size: 0.9rem;
}

.asset-value {
  width: 40px;
  text-align: left;
  padding-left: 1rem;
  font-size: 0.9rem;
  font-weight: 500;
}

.scale-markers {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.25rem;
  font-size: 0.7rem;
  color: #6B7280;
}

.line {
  height: 3px;
  background-color: #E5E7EB;
  position: relative;
  border-radius: 1.5px;
}

.marker {
  position: absolute;
  width: 12px;
  height: 12px;
  background-color: white;
  border: 2px solid #111827;
  border-radius: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

.chart-container {
  height: 400px;
  position: relative;
}

/* Add these styles for the date range picker */
.date-range-picker {
  margin-bottom: 1.5rem;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  padding: 1rem;
}

.date-range-picker h4 {
  margin-top: 0;
  margin-bottom: 1rem;
  font-size: 0.9rem;
  color: #6B7280;
}

.range-slider-container {
  position: relative;
  height: 30px;
  padding: 0 10px;
  margin-bottom: 1rem;
}

.range-track {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  height: 4px;
  width: 100%;
  background-color: #E5E7EB;
  border-radius: 2px;
}

.range-selected {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  height: 4px;
  background-color: #3B82F6;
  border-radius: 2px;
}

.range-handle {
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 16px;
  height: 16px;
  background-color: white;
  border: 2px solid #3B82F6;
  border-radius: 50%;
  cursor: pointer;
  z-index: 10;
}

.date-picker-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 1rem;
}

.date-picker {
  display: flex;
  flex-direction: column;
}

.date-picker label {
  font-size: 0.8rem;
  color: #6B7280;
  margin-bottom: 0.25rem;
}

.date-input-group {
  display: flex;
}

.date-input {
  width: 50px;
  padding: 0.25rem 0.5rem;
  border: 1px solid #E5E7EB;
  border-radius: 3px;
  text-align: center;
  margin-right: 0.25rem;
}

.date-input-group select {
  padding: 0.25rem 0.5rem;
}

.date-ticks {
  position: relative;
  height: 20px;
  margin-top: 5px;
}

.date-tick {
  position: absolute;
  top: 0;
  transform: translateX(-50%);
  font-size: 0.7rem;
  color: #6B7280;
}

/* Improve sub-asset styles for better alignment */
.sub-asset-label {
  text-align: right;
  padding-right: 1rem;
  font-size: 0.85rem;
  width: 120px; /* Same width as other asset labels */
  padding-left: 0;
  text-indent: 0;
}

.sub-asset-container {
  position: relative;
  width: calc(100% - 40px);
  margin-left: 20px;
  display: flex;
  flex-direction: column;
}

/* Position the sub-asset line to ensure center alignment */
.sub-asset-line {
  height: 3px;
  background-color: #E5E7EB;
  position: relative;
  border-radius: 1.5px;
  width: 100%;
}

/* Improved dropdown series selector */
.series-dropdown {
  position: relative;
  width: 180px;
  margin-top: 1rem;
}

.series-dropdown-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  padding: 0.5rem 1rem;
  cursor: pointer;
  font-size: 0.9rem;
  color: #374151;
  width: 100%;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.series-dropdown-toggle:hover {
  border-color: #D1D5DB;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

.series-dropdown-toggle span {
  margin-left: auto;
  transition: transform 0.2s;
}

.series-dropdown-toggle span.active {
  transform: rotate(180deg);
}

.series-dropdown-content {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 100;
  width: 250px;
  max-height: 300px;
  overflow: hidden;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  margin-top: 0.25rem;
  padding: 0.5rem;
  display: none;
}

.series-dropdown-content.active {
  display: block;
}

.series-options {
  max-height: 250px;
  overflow-y: auto;
  padding-right: 5px; /* Add some padding to account for scrollbar */
}

.series-option {
  padding: 0.5rem;
  display: flex;
  align-items: center;
  border-radius: 4px;
}

.series-option:hover {
  background-color: #F9FAFB;
}

.series-option input {
  margin-right: 0.5rem;
}

.series-color-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  margin-right: 0.5rem;
  border-radius: 2px;
}

.series-search {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  margin-bottom: 0.5rem;
  font-size: 0.85rem;
}

.series-select-actions {
  display: flex;
  justify-content: space-between;
  padding: 0.5rem;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid #E5E7EB;
}

.series-select-action {
  font-size: 0.85rem;
  color: #4F46E5;
  background-color: #F9FAFB;
  border: 1px solid #E5E7EB;
  cursor: pointer;
  padding: 0.4rem 0.75rem;
  border-radius: 4px;
  font-weight: 500;
  transition: background-color 0.2s, box-shadow 0.2s;
}

.series-select-action:hover {
  background-color: #F3F4F6;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* Date range section with series dropdown */
.date-range-section {
  margin-bottom: 1.5rem;
}

/* Move series dropdown into date selector */
.date-selector {
  margin-bottom: 1rem;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  padding: 1rem;
}

/* Improved series dropdown */
.series-dropdown {
  margin-top: 1rem;
  border-top: 1px solid #E5E7EB;
  padding-top: 1rem;
}

.series-dropdown-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  padding: 0.5rem 1rem;
  cursor: pointer;
  font-size: 0.9rem;
  color: #374151;
  width: 100%;
}

/* Consistent sub-asset line styling */
.sub-asset-label {
  text-align: right;
  padding-right: 1rem;
  font-size: 0.85rem;
  width: 120px; /* Same width as other asset labels */
}

/* Sub-asset line container to ensure alignment */
.sub-asset-container {
  position: relative;
  width: calc(100% - 40px); /* 20px less on each side */
  margin-left: 20px; /* Start 20px to the right */
}

/* Ensure scale markers are shown consistently */
.sub-asset-scale-markers {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.25rem;
  font-size: 0.7rem;
  color: #6B7280;
  position: relative;
  padding: 0;
  width: 100%;
}

/* Improved alignment for dropdown headers */
.date-selector h4 {
  margin-top: 0;
  margin-bottom: 1rem;
  font-size: 0.9rem;
  color: #6B7280;
}

/**
 * Series Dropdown Component
 * ------------------------
 * Unified styling for the series selection dropdown 
 * used in the Historical Allocation Targets section
 */
.series-dropdown {
  position: relative;
  width: 100%;
  margin-top: 0.5rem;
}

.series-dropdown-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  padding: 0.5rem 1rem;
  cursor: pointer;
  font-size: 0.9rem;
  color: #374151;
  width: 100%;
}

.series-dropdown-toggle::after {
  content: none; /* Remove default dropdown arrow */
}

.series-dropdown-toggle:hover {
  border-color: #D1D5DB;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

.series-dropdown-toggle span {
  margin-left: auto;
  transition: transform 0.2s;
}

.series-dropdown-toggle span.active {
  transform: rotate(180deg);
}

.series-dropdown-content {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 100;
  width: 250px;
  max-height: 300px;
  overflow: hidden;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  margin-top: 0.25rem;
  padding: 0.5rem;
  display: none;
}

.series-dropdown-content.active {
  display: block;
}

.series-options {
  max-height: 250px;
  overflow-y: auto;
  padding-right: 5px; /* Add some padding to account for scrollbar */
}

.series-option {
  padding: 0.5rem;
  display: flex;
  align-items: center;
  border-radius: 4px;
}

.series-option:hover {
  background-color: #F9FAFB;
}

.series-option input {
  margin-right: 0.5rem;
}

.series-color-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  margin-right: 0.5rem;
  border-radius: 2px;
}

.series-select-actions {
  display: flex;
  justify-content: space-between;
  padding: 0.5rem;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid #E5E7EB;
}

.series-select-action {
  font-size: 0.85rem;
  color: #4F46E5;
  background-color: #F9FAFB;
  border: 1px solid #E5E7EB;
  cursor: pointer;
  padding: 0.4rem 0.75rem;
  border-radius: 4px;
  font-weight: 500;
  transition: background-color 0.2s, box-shadow 0.2s;
}

.series-select-action:hover {
  background-color: #F3F4F6;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/**
 * Date Selectors & Containers
 * --------------------------
 * Styling for date selection components
 */
.date-selector-container {
  display: flex;
  flex-direction: column;
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 4px;
  padding: 1rem;
  margin-bottom: 1rem;
}

.date-inputs-row {
  display: flex;
  gap: 0.5rem; /* Reduce gap between start/end date */
  margin-bottom: 0.5rem;
}

.date-input-column {
  flex: 1;
  max-width: 180px; /* Limit width to create a more compact layout */
}

/* Backtest Tab Styles */
.backtest-tab {
  width: 100%;
  height: 100%;
  overflow-y: auto;
  padding: 1rem 2rem;
  background-color: #F9FAFB;
}

.backtest-container {
  width: 100%;
  max-width: none;
  margin: 0;
}

.portfolio-section {
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  padding: 1rem 1.5rem 1.5rem 1.5rem;
  margin-bottom: 1.5rem;
}

.portfolios-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.5rem;
  margin-top: 1rem;
}

.portfolio-card {
  background-color: #F9FAFB;
  border: 1px solid #E5E7EB;
  border-radius: 0.5rem;
  padding: 1rem;
}

.portfolio-title {
  font-size: 1rem;
  font-weight: 600;
  margin-bottom: 0.75rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.portfolio-allocations {
  margin-bottom: 1rem;
}

.portfolio-allocation-row {
  display: flex;
  justify-content: space-between;
  padding: 0.5rem 0;
  border-bottom: 1px solid #E5E7EB;
}

.portfolio-allocation-row:last-child {
  border-bottom: none;
}

.asset-name {
  flex: 1;
}

.asset-allocation {
  width: 80px;
  text-align: right;
  font-weight: 500;
}

.asset-weight-bar {
  flex: 1;
  margin: 0 1rem;
  position: relative;
  height: 18px;
}

.asset-weight-progress {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  height: 6px;
  background-color: #3B82F6;
  border-radius: 3px;
}

.optimization-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.control-group {
  background-color: white;
  border: 1px solid #E5E7EB;
  border-radius: 0.5rem;
  padding: 1rem;
}

.control-group h4 {
  margin-top: 0;
  margin-bottom: 0.75rem;
  font-size: 0.9rem;
  color: #6B7280;
}

.control-row {
  display: flex;
  margin-bottom: 0.75rem;
  align-items: center;
}

.control-label {
  width: 140px;
  font-size: 0.9rem;
}

.optimize-button {
  display: inline-block;
  padding: 0.5rem 1rem;
  background-color: #4F46E5;
  color: white;
  border: none;
  border-radius: 0.375rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.optimize-button:hover {
  background-color: #4338CA;
}

.reset-button {
  display: inline-block;
  padding: 0.5rem 1rem;
  background-color: white;
  color: #374151;
  border: 1px solid #E5E7EB;
  border-radius: 0.375rem;
  font-weight: 500;
  cursor: pointer;
  margin-left: 0.5rem;
  transition: background-color 0.2s;
}

.reset-button:hover {
  background-color: #F3F4F6;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
  margin-top: 1rem;
}

.metric-card {
  background-color: #F9FAFB;
  border: 1px solid #E5E7EB;
  border-radius: 0.5rem;
  padding: 1rem;
}

.metric-title {
  font-size: 0.9rem;
  color: #6B7280;
  margin-bottom: 0.5rem;
}

.metric-value {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
}

.metric-comparison {
  font-size: 0.8rem;
  margin-top: 0.25rem;
}

.metric-better {
  color: #10B981;
}

.metric-worse {
  color: #EF4444;
}

.constraint-row {
  display: flex;
  align-items: center;
  margin-bottom: 0.5rem;
}

.constraint-label {
  width: 140px;
  font-size: 0.9rem;
}

.constraint-inputs {
  display: flex;
  align-items: center;
}

.constraint-inputs input {
  width: 60px;
  padding: 0.25rem 0.5rem;
  border: 1px solid #E5E7EB;
  border-radius: 0.25rem;
  margin-right: 0.5rem;
  text-align: center;
}

.steps-container {
  margin-top: 1.5rem;
}

.step-row {
  display: flex;
  margin-bottom: 0.5rem;
  align-items: center;
}

.step-number {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background-color: #4F46E5;
  color: white;
  font-size: 0.8rem;
  font-weight: 600;
  margin-right: 0.75rem;
}

.step-text {
  font-size: 0.9rem;
  color: #374151;
}

.active-step .step-text {
  font-weight: 500;
  color: #111827;
}

.step-row.completed .step-number {
  background-color: #10B981;
}

.performance-chart-container {
  height: 350px;
  margin-top: 1rem;
}

.backtest-tab .performance-chart-container {
  height: 100%;
  min-height: 400px;
  margin-top: 0;
}

/* Range slider style for optimization parameters */
.range-slider {
  -webkit-appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: #E5E7EB;
  outline: none;
}

.range-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #4F46E5;
  cursor: pointer;
}

.range-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #4F46E5;
  cursor: pointer;
}

.slider-value {
  margin-left: 0.5rem;
  font-size: 0.9rem;
  font-weight: 500;
  width: 50px;
}

/* New Backtest Tab Styles */
.portfolio-weights-table {
  border: 1px solid #E5E7EB;
  border-radius: 0.5rem;
  overflow: hidden;
  background-color: white;
}

.table-header {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr;
  background-color: #F9FAFB;
  border-bottom: 1px solid #E5E7EB;
  font-weight: 600;
  font-size: 0.85rem;
  color: #374151;
}

.table-body {
  display: flex;
  flex-direction: column;
}

.table-row {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr;
  border-bottom: 1px solid #E5E7EB;
}

.table-row:last-child {
  border-bottom: none;
}

.sum-row {
  background-color: #F9FAFB;
  border-top: 2px solid #E5E7EB;
}

.asset-name-col, .weight-col {
  padding: 0.375rem 0.5rem;
  display: flex;
  align-items: center;
  font-size: 0.85rem;
}

.weight-input {
  width: 100%;
  padding: 0.375rem;
  border: 1px solid #E5E7EB;
  border-radius: 0.25rem;
  font-size: 0.85rem;
  text-align: right;
}

.weight-input:focus {
  outline: none;
  border-color: #3B82F6;
  box-shadow: 0 0 0 1px #3B82F6;
}

.optimized-weight {
  font-weight: 500;
  color: #374151;
  font-size: 0.85rem;
}

.sum-error {
  color: #EF4444 !important;
}

.preset-periods {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.preset-period {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
  color: #374151;
  cursor: pointer;
}

.preset-period input[type="radio"] {
  margin: 0;
}

.optimization-controls-new {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 0.375rem;
}

.control-group label {
  font-size: 0.9rem;
  font-weight: 500;
  color: #374151;
}

.control-select {
  padding: 0.5rem;
  border: 1px solid #E5E7EB;
  border-radius: 0.25rem;
  font-size: 0.9rem;
  background-color: white;
}

.control-select:focus {
  outline: none;
  border-color: #3B82F6;
  box-shadow: 0 0 0 1px #3B82F6;
}

.optimization-buttons {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.optimize-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.metrics-table-container {
  overflow-x: auto;
  border: 1px solid #E5E7EB;
  border-radius: 0.5rem;
  background-color: white;
}

.metrics-table {
  width: 100%;
  border-collapse: collapse;
}

.metrics-table th {
  background-color: #F9FAFB;
  padding: 1rem;
  text-align: left;
  font-weight: 600;
  font-size: 0.9rem;
  color: #374151;
  border-bottom: 1px solid #E5E7EB;
}

.metrics-table td {
  padding: 0.75rem 1rem;
  font-size: 0.9rem;
  color: #374151;
  border-bottom: 1px solid #F3F4F6;
}

.metrics-table tr:last-child td {
  border-bottom: none;
}

.metric-better {
  color: #10B981;
  font-weight: 500;
}

.metric-worse {
  color: #EF4444;
  font-weight: 500;
}
</style>
<script src="static_js/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<div id="app">
  <header>
    <div class="topbar">
      <div class="title-container">
        <img src="assets/logo.png" class="logo" alt="Logo">
        <h1 class="title">Research & Strategy Team Dashboard</h1>
      </div>
    </div>
    
    <div class="tabs-container">
  <nav class="tabs">
        <button :class="{active: currentTab==='Charts'}" @click="currentTab='Charts'">Charts</button>
        <button :class="{active: currentTab==='Target'}" @click="currentTab='Target'">Target</button>
        <button :class="{active: currentTab==='Backtest'}" @click="currentTab='Backtest'">Backtest</button>
        <button :class="{active: currentTab==='X Query'}" @click="currentTab='X Query'">X Query</button>
  </nav>
      
      <div class="action-buttons">
        <button class="action-button" @click="resetSelection">
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
            <path d="M3 3v5h5"></path>
            <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
          </svg>
          Reset Selection<span v-if="selectedChartCount > 0"> ({{ selectedChartCount }})</span>
        </button>
        <button class="action-button" @click="downloadSelectedCharts">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" x2="12" y1="15" y2="3"></line>
          </svg>
          Download PDF
        </button>
      </div>
    </div>
</header>

  <main>
    <!-- Loading indicator -->
    <div v-if="loading" class="loading-container">
      <p>Loading...</p>
    </div>

    <!-- CHARTS TAB - Only visible when Charts tab is selected -->
    <section v-else-if="currentTab==='Charts'" style="display:flex;width:100%;">
    <!-- SIDEBAR: categories -->
    <aside class="sidebar">
      <div v-for="cat in categories" :key="cat.name" class="cat">
        <div class="cat-hdr" @click="toggleCat(cat.name)">
            <div class="category-title-row">
              <span class="chevron" :class="{'chevron-expanded': openCat===cat.name}">&gt;</span>
              <span>{{ cat.name }}</span>
            </div>
          </div>

          <!-- Always keep this in the DOM but hide/show via CSS -->
          <div :style="{display: openCat===cat.name ? 'block' : 'none'}" class="cat-body">
            <!-- Select All checkbox -->
            <label class="select-all-label">
          <input type="checkbox"
                 :checked="isCatFull(cat)"
                 :indeterminate.prop="isCatPartial(cat)"
                     @change="handleSelectAllToggle(cat)">
              <span>Select All</span>
            </label>

            <!-- Individual label checkboxes -->
            <label v-for="lbl in cat.labels" :key="lbl" class="label-with-count">
              <div style="display: flex; align-items: flex-start;">
            <input type="checkbox"
                       :checked="selectedLabels[cat.name] && selectedLabels[cat.name].indexOf(lbl) !== -1"
                       @change="toggleLabel(cat.name, lbl)">
                <span class="label-text">{{ lbl }}</span>
              </div>
              <span class="label-count" v-if="getLabelSelectedCount(lbl) > 0">({{ getLabelSelectedCount(lbl) }})</span>
          </label>
        </div>
      </div>
    </aside>

    <!-- GRID -->
    <section class="grid">
        <div v-if="filteredCharts.length === 0" class="empty-state">
           No charts selected. Choose labels to display charts.
        </div>
        <div v-else class="charts-grid">
          <div class="card" 
               v-for="ch in filteredCharts" 
               :key="ch.id" 
               :data-chart-id="ch.id"
               :class="{selected: selectedCharts.includes(ch.id)}">
            <div class="chart-checkbox-container" @click.stop>
              <input type="checkbox" class="chart-checkbox" 
                     :checked="selectedCharts.includes(ch.id)" 
                     @change="toggleChartSelection(ch.id)">
            </div>
            <div class="card-image" @click="openModal(ch)">
              <component 
                :is="chartTag(ch)" 
                :src="ch.src" 
                loading="lazy"
                v-bind="getChartSpecificAttributes(ch)"
                @error="(e) => handleImageError(e, ch)">
              </component>
            </div>
            <div class="card-labels">
              Labels: {{ ch.labels.join(', ') }}
            </div>
          </div>
      </div>
    </section>
  </section>

    <!-- OTHER TABS - Only visible when respective tab is selected -->
    <section v-else-if="currentTab==='Target'" class="target-tab">
      <div class="target-container">
        <!-- Tabs for different allocation areas -->
        <div class="allocation-tabs">
          <button 
            v-for="tab in allocationTabs" 
            :key="tab.id"
            :class="{'active': currentAllocationTab === tab.id}"
            @click="currentAllocationTab = tab.id">
            {{ tab.name }}
          </button>
        </div>

        <!-- Line Format View -->
        <div class="allocation-section">
          <h3>Current Allocation Targets</h3>
          <div class="date-selector">
            <h4>Select Date</h4>
            <div class="date-input-group">
              <select v-model="selectedMonth" @change="updateSelectedDate">
                <option v-for="month in months" :key="month.value" :value="month.value">
                  {{ month.label }}
                </option>
              </select>
              <select v-model="selectedYear" @change="updateSelectedDate">
                <option v-for="year in years" :key="year" :value="year">{{ year }}</option>
              </select>
            </div>
          </div>
          
          <div class="allocation-lines">
            <!-- All tabs including Equities-Region use the same format now -->
            <div v-for="asset in currentAssets" :key="asset.name" class="allocation-line">
              <div class="asset-label">{{ formatAssetName(asset.name) }}</div>
              <div class="line-container">
                <div class="scale-markers">
                  <span>-10</span>
                  <span>-5</span>
                  <span>0</span>
                  <span>+5</span>
                  <span>+10</span>
                </div>
                <div class="line">
                  <div class="marker" :style="{ left: calculateMarkerPosition(asset.value) + '%' }"></div>
                </div>
              </div>
              <div class="asset-value">{{ Number(asset.value).toFixed(1) }}</div>
            </div>
          </div>
        </div>

        <!-- Time Series Chart -->
        <div class="time-series-section">
          <h3>Historical Allocation Targets</h3>
          <div class="date-selector-container">
            <!-- Create proper UI layout following UX best practices -->
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 1.5rem; max-width: 70%;">
              <!-- Left column: Date Range -->
              <div>
                <h4 style="margin: 0 0 0.75rem 0; font-size: 0.9rem; color: #6B7280; font-weight: 600;">Select Date Range</h4>
                <div style="display: flex; gap: 0.75rem;">
                  <!-- Start Date -->
                  <div style="flex: 1;">
                    <label style="display: block; margin-bottom: 0.5rem; font-size: 0.8rem; color: #6B7280;">Start Date</label>
                    <div class="date-input-group" style="display: flex; gap: 0.25rem;">
                      <select v-model="startMonth" @change="updateStartDate" style="flex: 1.2;">
                        <option v-for="month in months" :key="month.value" :value="month.value">
                          {{ month.label }}
                        </option>
                      </select>
                      <select v-model="startYear" @change="updateStartDate" style="flex: 1;">
                        <option v-for="year in years" :key="year" :value="year">{{ year }}</option>
                      </select>
                    </div>
                  </div>
                  
                  <!-- End Date -->
                  <div style="flex: 1;">
                    <label style="display: block; margin-bottom: 0.5rem; font-size: 0.8rem; color: #6B7280;">End Date</label>
                    <div class="date-input-group" style="display: flex; gap: 0.25rem;">
                      <select v-model="endMonth" @change="updateEndDate" style="flex: 1.2;">
                        <option v-for="month in months" :key="month.value" :value="month.value">
                          {{ month.label }}
                        </option>
                      </select>
                      <select v-model="endYear" @change="updateEndDate" style="flex: 1;">
                        <option v-for="year in years" :key="year" :value="year">{{ year }}</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Right column: Series Selection -->
              <div>
                <h4 style="margin: 0 0 0.75rem 0; font-size: 0.9rem; color: #6B7280; font-weight: 600;">Select Series</h4>
                <div class="series-dropdown" style="width: 85%;">
                  <div class="series-dropdown-toggle" @click="toggleSeriesDropdown" style="width: 100%;">
                    <span>Series ({{ selectedSeries.length }}/{{ availableDatasets.length }})</span>
                    <span :class="{'active': seriesDropdownOpen}" style="font-size: 0.8rem;">â–¼</span>
                  </div>
                  <div class="series-dropdown-content" :class="{'active': seriesDropdownOpen}" style="width: 200px;">
                    <div class="series-select-actions">
                      <button class="series-select-action" @click="selectAllSeries">Select All</button>
                      <button class="series-select-action" @click="deselectAllSeries">Deselect All</button>
                    </div>
                    <div class="series-options">
                      <div v-for="(dataset, index) in availableDatasets" :key="dataset.label" class="series-option">
                        <input type="checkbox" 
                               :id="'series-' + index" 
                               v-model="selectedSeries"
                               :value="dataset.label">
                        <span class="series-color-indicator" :style="{ backgroundColor: dataset.borderColor }"></span>
                        <label :for="'series-' + index">{{ dataset.label }}</label>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="chart-container">
            <canvas ref="timeSeriesChart"></canvas>
          </div>
        </div>
      </div>
    </section>
    <section v-else-if="currentTab==='Backtest'" class="backtest-tab">
      <div class="backtest-container">
        <!-- Main Portfolio Section with Chart -->
        <div class="portfolio-section">
          <h3 style="margin: 0 0 1rem 0;">Portfolio Construction & Optimization</h3>
          
          <div style="display: grid; grid-template-columns: 400px 1fr; gap: 2rem; align-items: start;">
            <!-- Left Column: Portfolio Weights and Controls -->
            <div>
              <h4 style="margin-bottom: 1rem; font-size: 1rem; color: #374151;">Portfolio Weights (%)</h4>
              
              <div class="portfolio-weights-table">
                <div class="table-header">
                  <div class="asset-name-col">Asset</div>
                  <div class="weight-col">Original</div>
                  <div class="weight-col">Optimized</div>
                </div>
                
                <div class="table-body">
                  <div v-for="(asset, index) in availableAssets" :key="asset" class="table-row">
                    <div class="asset-name-col">{{ asset }}</div>
                    <div class="weight-col">
                      <input type="number" 
                             v-model.number="originalWeights[asset]" 
                             @input="updatePortfolioReturns"
                             min="0" 
                             max="100" 
                             step="0.1" 
                             class="weight-input">
                    </div>
                    <div class="weight-col">
                      <span class="optimized-weight">{{ parseFloat(optimizedWeights[asset] || 0).toFixed(1) }}</span>
                    </div>
                  </div>
                  
                  <!-- Sum Row -->
                  <div class="table-row sum-row">
                    <div class="asset-name-col"><strong>Total</strong></div>
                    <div class="weight-col">
                      <strong :class="{'sum-error': originalWeightsSum !== 100}">{{ originalWeightsSum.toFixed(1) }}%</strong>
                    </div>
                    <div class="weight-col">
                      <strong :class="{'sum-error': optimizedWeightsSum !== 100}">{{ optimizedWeightsSum.toFixed(1) }}%</strong>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Time Period Selection -->
              <div style="margin-top: 1rem;">
                <h4 style="margin-bottom: 0.75rem; font-size: 1rem; color: #374151;">Backtest Period</h4>
                
                <!-- Predefined Periods -->
                <div class="period-selection">
                  <div class="preset-periods">
                    <label v-for="period in presetPeriods" :key="period.label" class="preset-period">
                      <input type="radio" 
                             name="period" 
                             :value="period.label"
                             v-model="selectedPresetPeriod"
                             @change="selectPresetPeriod(period)">
                      <span>{{ period.label }}</span>
                    </label>
                  </div>
                  
                  <div class="custom-period" style="margin-top: 0.75rem;">
                    <label class="preset-period">
                      <input type="radio" 
                             name="period" 
                             value="custom"
                             v-model="selectedPresetPeriod">
                      <span>Custom Period: <span style="font-size: 0.75rem; color: #6B7280; font-weight: normal;">(Note: start from when all selected assets have data)</span></span>
                    </label>
                    
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; margin-left: 1.5rem;">
                      <div>
                        <label style="font-size: 0.8rem; color: #6B7280;">Start</label>
                        <div style="display: flex; gap: 0.25rem;">
                          <select v-model="customStartMonth" @change="updateCustomPeriod" style="width: 70px;">
                            <option v-for="month in months" :key="month.value" :value="month.value">
                              {{ month.label }}
                            </option>
                          </select>
                          <select v-model="customStartYear" @change="updateCustomPeriod" style="width: 80px;">
                            <option v-for="year in availableYears" :key="year" :value="year">{{ year }}</option>
                          </select>
                        </div>
                      </div>
                      
                      <div>
                        <label style="font-size: 0.8rem; color: #6B7280;">End</label>
                        <div style="display: flex; gap: 0.25rem;">
                          <select v-model="customEndMonth" @change="updateCustomPeriod" style="width: 70px;">
                            <option v-for="month in months" :key="month.value" :value="month.value">
                              {{ month.label }}
                            </option>
                          </select>
                          <select v-model="customEndYear" @change="updateCustomPeriod" style="width: 80px;">
                            <option v-for="year in availableYears" :key="year" :value="year">{{ year }}</option>
                          </select>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Optimization Controls moved below -->
              <div style="margin-top: 1rem;">
                <h4 style="margin-bottom: 0.75rem; font-size: 1rem; color: #374151;">Optimization Settings</h4>
                
                <div class="optimization-controls-new">
                  <div class="control-group">
                    <label>Objective Function:</label>
                    <select v-model="optimizationObjective" class="control-select">
                      <option value="sharpe">Maximize Sharpe Ratio</option>
                      <option value="risk">Minimize Risk</option>
                      <option value="sortino">Maximize Sortino Ratio</option>
                      <option value="cvar">Minimize CVaR</option>
                    </select>
                  </div>
                  
                  <div class="control-group">
                    <label>Optimization Starting State:</label>
                    <select v-model="optimizationStartingState" class="control-select">
                      <option value="original">Original Portfolio</option>
                      <option value="optimized">Optimized Portfolio</option>
                    </select>
                  </div>
                  
                  <div class="control-group">
                    <label>Turnover Limit:</label>
                    <select v-model="stepSize" class="control-select">
                      <option value="1">1%</option>
                      <option value="2">2%</option>
                      <option value="3">3%</option>
                      <option value="4">4%</option>
                      <option value="5">5%</option>
                      <option value="6">6%</option>
                      <option value="7">7%</option>
                      <option value="8">8%</option>
                    </select>
                  </div>
                  
                  <div class="optimization-buttons" style="margin-top: 1rem;">
                    <button class="optimize-button" @click="runOptimization" :disabled="!canOptimize">
                      Optimize Portfolio
                    </button>
                    <button class="reset-button" @click="resetOptimization">
                      Reset Optimized
                    </button>
                  </div>
                  
                  <div v-if="optimizationStatus" class="optimization-status" style="margin-top: 1rem;">
                    <p style="font-size: 0.9rem; color: #6B7280;">{{ optimizationStatus }}</p>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Right Column: Cumulative Returns Chart and Metrics -->
            <div>
              <h4 style="margin-bottom: 1rem; font-size: 1rem; color: #374151;">Historical Cumulative Returns</h4>
              
              <div class="performance-chart-container" style="height: 400px; margin-bottom: 2rem;">
                <canvas ref="cumulativeReturnsChart"></canvas>
              </div>
              
              <!-- Performance Metrics Table moved here -->
              <div>
                <h4 style="margin-bottom: 1rem; font-size: 1rem; color: #374151;">Performance Metrics</h4>
                
                <div class="metrics-table-container">
                  <table class="metrics-table">
                    <thead>
                      <tr>
                        <th>Metric</th>
                        <th>Original Portfolio</th>
                        <th>Optimized Portfolio</th>
                        <th>Difference</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Return (CAGR)</td>
                        <td>{{ formatMetric(performanceMetrics.original.cagr, '%') }}</td>
                        <td>{{ formatMetric(performanceMetrics.optimized.cagr, '%') }}</td>
                        <td :class="getMetricClass('cagr')">{{ formatDifference(performanceMetrics.optimized.cagr, performanceMetrics.original.cagr, '%') }}</td>
                      </tr>
                      <tr>
                        <td>Volatility</td>
                        <td>{{ formatMetric(performanceMetrics.original.volatility, '%') }}</td>
                        <td>{{ formatMetric(performanceMetrics.optimized.volatility, '%') }}</td>
                        <td :class="getMetricClass('volatility')">{{ formatDifference(performanceMetrics.optimized.volatility, performanceMetrics.original.volatility, '%') }}</td>
                      </tr>
                      <tr>
                        <td>Sharpe Ratio</td>
                        <td>{{ formatMetric(performanceMetrics.original.sharpe) }}</td>
                        <td>{{ formatMetric(performanceMetrics.optimized.sharpe) }}</td>
                        <td :class="getMetricClass('sharpe')">{{ formatDifference(performanceMetrics.optimized.sharpe, performanceMetrics.original.sharpe) }}</td>
                      </tr>
                      <tr>
                        <td>Sortino Ratio</td>
                        <td>{{ formatMetric(performanceMetrics.original.sortino) }}</td>
                        <td>{{ formatMetric(performanceMetrics.optimized.sortino) }}</td>
                        <td :class="getMetricClass('sortino')">{{ formatDifference(performanceMetrics.optimized.sortino, performanceMetrics.original.sortino) }}</td>
                      </tr>
                      <tr>
                        <td>CVaR (5%)</td>
                        <td>{{ formatMetric(performanceMetrics.original.cvar, '%') }}</td>
                        <td>{{ formatMetric(performanceMetrics.optimized.cvar, '%') }}</td>
                        <td :class="getMetricClass('cvar')">{{ formatDifference(performanceMetrics.optimized.cvar, performanceMetrics.original.cvar, '%') }}</td>
                      </tr>
                      <tr>
                        <td>Max Drawdown</td>
                        <td>{{ formatMetric(performanceMetrics.original.maxDrawdown, '%') }}</td>
                        <td>{{ formatMetric(performanceMetrics.optimized.maxDrawdown, '%') }}</td>
                        <td :class="getMetricClass('maxDrawdown')">{{ formatDifference(performanceMetrics.optimized.maxDrawdown, performanceMetrics.original.maxDrawdown, '%') }}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section v-else-if="currentTab==='X Query'" class="empty-tab">
      <div class="empty-state">Changes are coming soon!</div>
    </section>
</main>

  <!-- ZOOM MODAL -->
  <div class="modal-overlay" :class="{visible: isModalVisible}" @click.self="closeModal">
      <div class="modal-content" v-if="zoomedChart">
        <button class="modal-close" @click="closeModal">&times;</button>
        <div class="modal-image-container">
             <component 
                :is="chartTag(zoomedChart)" 
                :src="zoomedChart.src"
                v-bind="getChartSpecificAttributes(zoomedChart)">
            </component>
        </div>
        <div class="modal-labels">
            Labels: {{ zoomedChart.labels.join(', ') }}
        </div>
      </div>
  </div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

<!-- Portfolio calculation libraries -->
<script src="js/portfolio-metrics.js"></script>
<script src="js/portfolio-optimization.js"></script>

<script>
/* injected by build.py */
const charts = [[ charts|safe ]];
const categories = [[ cats|safe ]];
const allocationData = [[ allocation|safe ]];
const returnsData = [[ returns|safe ]];

/* Vue logic */
new Vue({
  el:'#app',
  data:{
    charts,
    categories,
    selectedLabels: {}, 
    openCat: null,
    tabs: ['Charts', 'Target', 'Backtest', 'X Query'],
    currentTab: 'Charts',
    loading: true,
    _justToggledSelectAll: false, 
    isModalVisible: false,      
    zoomedChart: null,
    selectedCharts: [],
    
    // Target tab data
    allocationTabs: [
      { id: 'Cross Assets', name: 'Cross Assets' },
      { id: 'Equities-Region', name: 'Equity - Region' },
      { id: 'Equities-Sector', name: 'Equity - Sector' },
      { id: 'Bonds-Region', name: 'Bond - Region' },
      { id: 'Bonds-Sector', name: 'Bond - Sector' },
      { id: 'FX', name: 'FX' },
      { id: 'Commodities', name: 'Commodities' }
    ],
    currentAllocationTab: 'Cross Assets',
    allocationDates: [],
    selectedAllocationDate: '',
    timeSeriesStartDate: '',
    timeSeriesEndDate: '',
    currentAssets: [],
    timeSeriesChart: null,
    
    // Add these properties for the date range picker
    months: [
      { label: 'Jan', value: '01' },
      { label: 'Feb', value: '02' },
      { label: 'Mar', value: '03' },
      { label: 'Apr', value: '04' },
      { label: 'May', value: '05' },
      { label: 'Jun', value: '06' },
      { label: 'Jul', value: '07' },
      { label: 'Aug', value: '08' },
      { label: 'Sep', value: '09' },
      { label: 'Oct', value: '10' },
      { label: 'Nov', value: '11' },
      { label: 'Dec', value: '12' }
    ],
    years: [],
    selectedMonth: '01',
    selectedYear: 2024,
    startMonth: '01',
    startYear: 2024,
    endMonth: '12',
    endYear: 2024,
    dragging: null,
    dateTicks: [],
    availableDatasets: [],
    selectedSeries: [],
    allSeriesSelected: true,
    seriesDropdownOpen: false,
    optimizationObjective: 'sharpe',
    optimizationStartingState: 'original',
    riskTolerance: 5,
    timeHorizon: '5',
    minEquity: 20,
    maxEquity: 80,
    minBonds: 20,
    maxBonds: 60,
    minCash: 0,
    maxCash: 20,
    minAlts: 0,
    maxAlts: 30,
    currentStep: 0,
    originalPortfolio: [
      { asset: 'US Equities', weight: 40 },
      { asset: 'International Equities', weight: 20 },
      { asset: 'US Bonds', weight: 30 },
      { asset: 'Cash', weight: 10 },
      { asset: 'Alternatives', weight: 0 }
    ],
    optimizedPortfolio: [
      { asset: 'US Equities', weight: 0 },
      { asset: 'International Equities', weight: 0 },
      { asset: 'US Bonds', weight: 0 },
      { asset: 'Cash', weight: 0 },
      { asset: 'Alternatives', weight: 0 }
    ],
    performanceMetrics: {
      originalReturn: 7.2,
      optimizedReturn: 0,
      originalVolatility: 12.5,
      optimizedVolatility: 0,
      originalSharpe: 0.58,
      optimizedSharpe: 0,
      originalDrawdown: 18.4,
      optimizedDrawdown: 0
    },
    portfolioPerformanceChart: null,
    originalWeights: {},
    optimizedWeights: {},
    originalWeightsSum: 0,
    optimizedWeightsSum: 0,
    selectedPresetPeriod: 'custom',
    customStartMonth: '01',
    customStartYear: 2024,
    customEndMonth: '12',
    customEndYear: 2024,
    availableYears: [],
    stepSize: 1,
    optimizationStatus: null,
    
    // New backtest data
    availableAssets: [],
    presetPeriods: [
      { label: '2008-2009: Great Financial Crisis', start: '2008-01', end: '2009-12' },
      { label: '2012-2013: European Debt Crisis', start: '2012-01', end: '2013-12' },
      { label: '2015-2016: Oil Shock, China Crash', start: '2015-01', end: '2016-12' },
      { label: '2018-2019: The First Trade War', start: '2018-01', end: '2019-12' },
      { label: '2020-2021: Covid Pandemic', start: '2020-01', end: '2021-12' }
    ],
    backtestStartDate: '',
    backtestEndDate: '',
    cumulativeReturnsChart: null,
    performanceMetrics: {
      original: {
        cagr: 0,
        volatility: 0,
        sharpe: 0,
        sortino: 0,
        cvar: 0,
        maxDrawdown: 0
      },
      optimized: {
        cagr: 0,
        volatility: 0,
        sharpe: 0,
        sortino: 0,
        cvar: 0,
        maxDrawdown: 0
      }
    }
  },
  mounted() {
    this.categories.forEach(cat => {
       this.$set(this.selectedLabels, cat.name, []);
    });

    // Start with all categories collapsed
    this.openCat = null;

    setTimeout(() => {
      this.loading = false;
    }, 800);

    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && this.isModalVisible) {
            this.closeModal();
        }
    });

    // Initialize allocation data
    this.initializeAllocationData();
    
    // Initialize backtest data
    this.initializeBacktestData();

    // Initialize the performance chart when the backtest tab is first shown
    this.$nextTick(() => {
      if (this.currentTab === 'Backtest') {
        this.initPerformanceChart();
      }
    });
  },
  computed:{
    filteredCharts(){
      const categoriesWithSelections = Object.keys(this.selectedLabels)
        .filter(catName => this.selectedLabels[catName] && this.selectedLabels[catName].length > 0);

      // If no labels selected, show all charts
      if (categoriesWithSelections.length === 0) return this.charts;

      // Filter charts where ALL selected category has AT LEAST ONE matching label
      return this.charts.filter(chart => {
        return categoriesWithSelections.every(catName => {
          const selectedLabelsInCategory = this.selectedLabels[catName];
          // At least one label from this category matches
          return selectedLabelsInCategory.some(label => {
            return chart.labels.includes(label);
          });
        });
      });
    },
    selectedChartCount() {
      return this.selectedCharts.length;
    },
    isOptimizedReturnBetter() {
      return this.performanceMetrics.optimizedReturn > this.performanceMetrics.originalReturn;
    },
    isOptimizedVolatilityBetter() {
      return this.performanceMetrics.optimizedVolatility < this.performanceMetrics.originalVolatility;
    },
    isOptimizedSharpeBetter() {
      return this.performanceMetrics.optimizedSharpe > this.performanceMetrics.originalSharpe;
    },
    isOptimizedDrawdownBetter() {
      return this.performanceMetrics.optimizedDrawdown < this.performanceMetrics.originalDrawdown;
    },
    canOptimize() {
      return Math.abs(this.originalWeightsSum - 100) < 0.1;
    }
  },
  methods:{
    /**
     * Toggle category expansion in the sidebar
     * @param {string} c - The category name to toggle
     */
    toggleCat(c){
       if (this.openCat === c && !this._justToggledSelectAll) {
         this.openCat = null;
       } else {
         this.openCat = c;
       }
       this._justToggledSelectAll = false;
    },
    
    /**
     * Toggle selection of a specific label within a category
     * @param {string} category - The category name
     * @param {string} label - The label to toggle
     */
    toggleLabel(category, label){
       const labels = this.selectedLabels[category];
       const index = labels.indexOf(label);

       if (index === -1) {
         labels.push(label);
       } else {
         labels.splice(index, 1);
       }
       this.$set(this.selectedLabels, category, labels);
    },
    
    /**
     * Handle the "Select All" checkbox toggle
     * @param {Object} cat - The category object
     */
    handleSelectAllToggle(cat) {
      this.toggleSelectAll(cat);
      this._justToggledSelectAll = true;
      this.openCat = cat.name;
    },
    
    /**
     * Toggle selection state of all labels in a category
     * @param {Object} cat - The category object
     */
    toggleSelectAll(cat){
      const categoryLabels = cat.labels;
      const allSelected = this.isCatFull(cat);

      if (allSelected) {
        this.$set(this.selectedLabels, cat.name, []);
      } else {
        this.$set(this.selectedLabels, cat.name, [...categoryLabels]);
      }
    },
    
    /**
     * Check if all labels in a category are selected
     * @param {Object} cat - The category object
     * @returns {boolean} - True if all labels are selected
     */
    isCatFull(cat){
      const labels = this.selectedLabels[cat.name];
      if (!labels) return false;
      if (cat.labels.length === 0) return false;
      return cat.labels.every(label => labels.includes(label)) && labels.length === cat.labels.length;
    },
    
    /**
     * Check if some but not all labels in a category are selected
     * @param {Object} cat - The category object
     * @returns {boolean} - True if some but not all labels are selected
     */
    isCatPartial(cat){
       const labels = this.selectedLabels[cat.name];
       if (!labels || labels.length === 0) return false;
       return !this.isCatFull(cat);
    },
    
    /**
     * Determine the appropriate HTML tag for a chart based on its type
     * @param {Object} ch - The chart object
     * @returns {string} - Either 'img' or 'iframe'
     */
    chartTag(ch) {
      if (ch.kind === 'local_png' || ch.kind === 'remote_img') {
        return 'img';
      } else {
        return 'iframe';
      }
    },
    
    /**
     * Get additional attributes for chart elements based on their type
     * @param {Object} ch - The chart object
     * @returns {Object} - Attributes to add to the element
     */
    getChartSpecificAttributes(ch) {
        if (this.chartTag(ch) === 'iframe') {
            return {
                frameborder: "0",
                scrolling: "no" // CSS overflow:hidden on the iframe element is more reliable
            };
        }
        return {};
    },
    
    /**
     * Open the modal to show a zoomed version of a chart
     * @param {Object} chart - The chart to display
     */
    openModal(chart) {
        this.zoomedChart = chart;
        this.isModalVisible = true;
        document.body.style.overflow = 'hidden'; 
    },
    
    /**
     * Close the chart zoom modal
     */
    closeModal() {
        this.isModalVisible = false;
        this.zoomedChart = null;
        document.body.style.overflow = ''; 
    },
    
    /**
     * Handle image loading errors
     * @param {Event} event - The error event
     * @param {Object} chart - The chart that failed to load
     */
    handleImageError(event, chart) {
      console.error(`Failed to load image: ${chart.src}`);
      event.target.alt = 'Image failed to load';
    },
    
    /**
     * Get count of selected charts with a specific label
     * @param {string} label - The label to count
     * @returns {number} - Count of selected charts with this label
     */
    getLabelSelectedCount(label) {
      return this.charts.filter(chart => 
        chart.labels.includes(label) && this.selectedCharts.includes(chart.id)
      ).length;
    },
    
    /**
     * Toggle selection of a chart
     * @param {string} chartId - The ID of the chart to toggle
     */
    toggleChartSelection(chartId) {
      const index = this.selectedCharts.indexOf(chartId);
      if (index === -1) {
        this.selectedCharts.push(chartId);
      } else {
        this.selectedCharts.splice(index, 1);
      }
    },
    
    /**
     * Reset all chart selections
     */
    resetSelection() {
      this.selectedCharts = [];
    },

    /**
     * Download selected charts as PDF
     */
     async downloadSelectedCharts() {
      if (this.selectedCharts.length === 0) {
        alert("Pick at least one chart first ðŸ™‚");
        return;
      }

      // Check if required libraries are loaded
      if (typeof window.jspdf === 'undefined') {
        alert("jsPDF library is not loaded. Please refresh the page and try again.");
        return;
      }

      if (typeof PDFLib === 'undefined') {
        alert("pdf-lib library is not loaded. Please refresh the page and try again.");
        return;
      }

      // Add progress feedback
      const progressDiv = document.createElement('div');
      progressDiv.id = 'download-progress';
      progressDiv.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 8px;
        z-index: 10000; font-family: Arial, sans-serif; text-align: center;
      `;
      progressDiv.innerHTML = `
        <div>Preparing PDF download...</div>
        <div id="progress-text">Starting...</div>
        <div style="width: 300px; height: 6px; background: #333; border-radius: 3px; margin: 10px 0;">
          <div id="progress-bar" style="width: 0%; height: 100%; background: #4CAF50; border-radius: 3px; transition: width 0.3s;"></div>
        </div>
      `;
      document.body.appendChild(progressDiv);

      const updateProgress = (text, percent) => {
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        if (progressText) progressText.textContent = text;
        if (progressBar) progressBar.style.width = percent + '%';
        console.log(`Progress: ${percent}% - ${text}`);
      };

      try {
        const { jsPDF } = window.jspdf;
        // Use explicit A4 landscape dimensions for consistency with compression enabled
        const pdf = new jsPDF({
          orientation: 'landscape',
          unit: 'mm',
          format: 'a4',  // Explicit A4 format (297mm x 210mm in landscape)
          compress: true  // Enable PDF compression for smaller file size
        });
        let isFirstPage = true;

        updateProgress("Initializing PDF...", 5);

        // Get the full chart objects from selected IDs
        const selectedChartData = this.charts.filter(chart => 
          this.selectedCharts.includes(chart.id)
        );
        
        console.log(`Processing ${selectedChartData.length} selected charts:`, this.selectedCharts);

        for (let i = 0; i < selectedChartData.length; i++) {
          const chart = selectedChartData[i];
          const progressPercent = 5 + (i / selectedChartData.length) * 90;
          
          updateProgress(`Processing ${chart.title} (${i + 1}/${selectedChartData.length})`, progressPercent);
          console.log(`Processing chart ${i + 1}/${selectedChartData.length}: ${chart.title}`);

          if (!isFirstPage) {
            pdf.addPage();
          }
          isFirstPage = false;

          // Add chart title at the top (moved further up)
          pdf.setTextColor(0, 182, 36); // Green color RGB(0,182,36)
          pdf.setFontSize(28); // Increased font size to 28
          pdf.setFont(undefined, 'normal'); // Removed bold
          pdf.text(chart.title, 20, 12); // Moved further up from 18 to 12

          try {
            let dataURL = null;
            let imageWidth = 220, imageHeight = 160; // Default dimensions
            let chartX = 0, chartY = 30; // Default positioning

            if (chart.kind === 'local_png') {
              console.log(`Loading local image: ${chart.title}`);
              updateProgress(`Loading ${chart.title}...`, progressPercent + 2);
              
              // ROBUST LOCAL IMAGE SOLUTION
              console.log(`ðŸ–¼ï¸ Processing local image: ${chart.src}`);
              
              // Check if we're running on HTTP(S) or file:// protocol
              const isFileProtocol = window.location.protocol === 'file:';
              
              if (isFileProtocol) {
                // For file:// protocol, recommend HTTP server
                throw new Error(`Local images require an HTTP server for PDF generation. Please run 'python -m http.server 8000' in your project directory and access via http://localhost:8000 instead of opening the HTML file directly. Image: ${chart.src}`);
              }
              
              // For HTTP protocol, try to load the image
              const imagePath = chart.src.startsWith('/') ? chart.src : './' + chart.src;
              console.log(`ðŸ”„ Loading image via HTTP: ${imagePath}`);
              
              const img = new Image();
              img.crossOrigin = 'anonymous'; // Allow cross-origin for local server
              
              dataURL = await new Promise((resolve, reject) => {
                img.onload = () => {
                  try {
                    // Create canvas and draw image with optimized resolution for smaller file size
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Keep original pixels for maximum quality - no pre-scaling blur
                    const scaleFactor = 1;  // Use original size for maximum quality
                    canvas.width = img.naturalWidth * scaleFactor;
                    canvas.height = img.naturalHeight * scaleFactor;
                    
                    // Enable highest quality image smoothing
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Use PNG for lossless compression - no JPEG artifacts
                    const dataURL = canvas.toDataURL('image/png');
                    
                    // Validate the data URL
                    if (dataURL.length < 100) {
                      reject(new Error('Generated image data is too small, possibly corrupt'));
                    } else {
                      resolve(dataURL);
                    }
                  } catch (canvasError) {
                    reject(new Error(`Canvas error: ${canvasError.message}. Try running a local HTTP server.`));
                  }
                };
                
                img.onerror = () => {
                  reject(new Error(`Failed to load image: ${imagePath}. Make sure the file exists and you're running an HTTP server (try 'python -m http.server 8000').`));
                };
                
                img.src = imagePath;
              });
              
              console.log(`âœ… Successfully loaded local image: ${chart.title} (${dataURL.length} chars)`);
            } else if (chart.kind === 'remote_img') {
              updateProgress(`Fetching ${chart.title}...`, progressPercent + 2);
              console.log(`Fetching remote image via CORS proxy: ${chart.title}`);
              console.log(`Chart ID: ${chart.id}, Original URL: ${chart.original_src}`);
              console.log(`Using proxy URL: ${chart.src}`);
              
              try {
                // Use direct fetch through CORS proxy with enhanced error handling
                dataURL = await this.fetchImageThroughProxy(chart);
                console.log(`âœ… Successfully fetched ${chart.title} via proxy (${dataURL.length} chars)`);
              } catch (fetchError) {
                console.error(`âŒ Failed to fetch ${chart.title}:`, fetchError);
                
                // Try direct fallback to original URL as last resort
                console.log(`Attempting direct fallback to original URL: ${chart.original_src}`);
                try {
                  const fallbackResponse = await fetch(chart.original_src, {
                    mode: 'no-cors',
                    cache: 'default'
                  });
                  console.log(`Direct fallback response: ${fallbackResponse.status}`);
                  // Note: no-cors won't let us read the response, so this is mostly for debugging
                } catch (directError) {
                  console.log(`Direct URL also failed: ${directError.message}`);
                }
                
                throw fetchError; // Re-throw the original error
              }
            }

            // Add the image to PDF if we got one
            if (dataURL && dataURL.length > 100) { // Basic check for valid data URL
              updateProgress(`Adding ${chart.title} to PDF...`, progressPercent + 4);
              console.log(`Adding image to PDF: ${chart.title}`);
              
              // Calculate 300 DPI sizing from original image dimensions
              // If we have the image data, extract dimensions for proper 300 DPI calculation
              
              try {
                // Extract image dimensions from data URL for proper 300 DPI sizing
                const tempImg = new Image();
                await new Promise((resolve) => {
                  tempImg.onload = resolve;
                  tempImg.src = dataURL;
                });
                
                // For A4 landscape (297mm x 210mm), use much more space available
                // Calculate optimal size while maintaining aspect ratio
                const aspectRatio = tempImg.naturalWidth / tempImg.naturalHeight;
                
                // Use much larger dimensions to fill most of the page
                const maxWidth = 260;  // Increased significantly from 240mm
                const maxHeight = 160; // Increased significantly from 140mm
                
                if (aspectRatio > maxWidth / maxHeight) {
                  // Image is wider - fit to width
                  imageWidth = maxWidth;
                  imageHeight = maxWidth / aspectRatio;
                } else {
                  // Image is taller - fit to height  
                  imageHeight = maxHeight;
                  imageWidth = maxHeight * aspectRatio;
                }
                
                console.log(`Large chart sizing: ${tempImg.naturalWidth}x${tempImg.naturalHeight} -> ${imageWidth.toFixed(1)}x${imageHeight.toFixed(1)}mm`);
              } catch (e) {
                console.log('Using default large dimensions for image sizing');
              }
              
              // Layout: Title (top), Chart (centered), Labels & Source (bottom)
              // Use PNG format and turn off jsPDF re-compression for maximum quality
              // Center the chart both horizontally and vertically on the page
              const pageWidth = 297; // A4 landscape width
              const pageHeight = 210; // A4 landscape height
              chartX = (pageWidth - imageWidth) / 2; // Center horizontally
              chartY = 30; // Moved down slightly from 25 for better positioning
              pdf.addImage(dataURL, 'PNG', chartX, chartY, imageWidth, imageHeight, undefined, 'FAST');
              
              // Add labels and source closer to the chart and aligned to chart's left edge
              pdf.setTextColor(60, 60, 60); // Dark gray
              pdf.setFontSize(10);
              pdf.setFont(undefined, 'normal');
              const labelsY = chartY + imageHeight + 5; // Tighter spacing - reduced from 10 to 5
              pdf.text(`Labels: ${chart.labels.join(', ')}`, chartX, labelsY); // Aligned to chart's left edge
              if (chart.source) {
                pdf.setFont(undefined, 'italic');
                pdf.text(`Source: ${chart.source}`, chartX, labelsY + 6); // Reduced spacing from 10 to 6
              }
              
              console.log(`âœ… Successfully added ${chart.title} to PDF`);
            } else {
              throw new Error('Failed to generate image data or data is too small');
            }

          } catch (error) {
            console.error(`âŒ Error processing ${chart.title}:`, error);
            
            // Add error message to PDF instead of failing completely
            pdf.setFontSize(12);
            pdf.setTextColor(255, 0, 0); // Red text
            pdf.text(`âŒ Could not fetch image`, 20, 60); // Moved down from 50 to 60
            
            // Split long error messages into multiple lines manually
            const errorMsg = `Error: ${error.message}`;
            const maxLineLength = 80; // Approximate characters per line
            const errorLines = [];
            
            for (let i = 0; i < errorMsg.length; i += maxLineLength) {
              errorLines.push(errorMsg.substring(i, i + maxLineLength));
            }
            
            let yPos = 75; // Moved down from 65 to 75
            errorLines.forEach(line => {
              pdf.text(line, 20, yPos);
              yPos += 15;
            });
            
            pdf.text(`Chart ID: ${chart.id}`, 20, yPos + 5);
            pdf.text(`Source: ${chart.src}`, 20, yPos + 20);
            pdf.setTextColor(0, 0, 0); // Reset to black
            
            // Still add labels and source at bottom for reference - use safe positioning
            pdf.setTextColor(60, 60, 60); // Dark gray
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'normal');
            const safeLabelsY = 180; // Use fixed safe position instead of dynamic positioning
            pdf.text(`Labels: ${chart.labels.join(', ')}`, 20, safeLabelsY);
            if (chart.source) {
              pdf.setFont(undefined, 'italic');
              pdf.text(`Source: ${chart.source}`, 20, safeLabelsY + 12);
            }
          }
        }

        updateProgress("Generating PDF file...", 95);
        console.log("Merging with cover page...");
        
        // Generate charts PDF as blob instead of saving directly
        const chartsPdfBlob = pdf.output('blob');
        
        // Merge with cover page
        await this.buildFinalPdf(chartsPdfBlob);
        
        updateProgress("Download complete!", 100);
        console.log("âœ… PDF download completed successfully");
        
        // Remove progress indicator after a short delay
        setTimeout(() => {
          const progressElement = document.getElementById('download-progress');
          if (progressElement) progressElement.remove();
        }, 1500);

      } catch (error) {
        console.error("âŒ Error creating PDF:", error);
        alert(`Error creating PDF: ${error.message}`);
        
        // Remove progress indicator
        const progressElement = document.getElementById('download-progress');
        if (progressElement) progressElement.remove();
      }
    },

    /**
     * Merge cover.pdf with generated charts PDF using pdf-lib
     */
    async buildFinalPdf(chartPdfBlob) {
      try {
        console.log("Loading cover.pdf and content_page.pdf...");
        
        // 1. Fetch both cover.pdf and content_page.pdf as ArrayBuffers
        const [coverBytes, contentBytes] = await Promise.all([
          fetch('cover.pdf').then(r => {
            if (!r.ok) {
              throw new Error(`Failed to load cover.pdf: ${r.status} ${r.statusText}`);
            }
            return r.arrayBuffer();
          }),
          fetch('content_page.pdf').then(r => {
            if (!r.ok) {
              throw new Error(`Failed to load content_page.pdf: ${r.status} ${r.statusText}`);
            }
            return r.arrayBuffer();
          })
        ]);

        console.log("Loading PDFs in pdf-lib...");
        
        // 2. Load all PDFs in pdf-lib
        const [coverDoc, contentDoc, chartsDoc] = await Promise.all([
          PDFLib.PDFDocument.load(coverBytes),
          PDFLib.PDFDocument.load(contentBytes),
          PDFLib.PDFDocument.load(await chartPdfBlob.arrayBuffer())
        ]);

        console.log("Using cover page dimensions as standard...");
        
        // 3. Create a new document using cover page dimensions as the standard
        const finalDoc = await PDFLib.PDFDocument.create();
        
        // Get the cover page and use its dimensions as our standard
        const coverPage = coverDoc.getPage(0);
        const { width: pageWidth, height: pageHeight } = coverPage.getSize();
        
        // Get the content page template
        const contentPage = contentDoc.getPage(0);
        
        console.log(`Using cover page dimensions as standard: ${pageWidth} x ${pageHeight}`);
        
        // 4. Add the cover page (no scaling needed since it's our reference size)
        const newCoverPage = finalDoc.addPage([pageWidth, pageHeight]);
        const embeddedCoverPage = await finalDoc.embedPage(coverPage);
        newCoverPage.drawPage(embeddedCoverPage, {
          x: 0,
          y: 0,
          width: pageWidth,
          height: pageHeight
        });
        
        // 5. Process all chart pages using content page as template
        const chartPages = chartsDoc.getPages();
        for (let i = 0; i < chartPages.length; i++) {
          const chartPage = chartPages[i];
          const { width: chartWidth, height: chartHeight } = chartPage.getSize();
          
          console.log(`Processing chart page ${i + 1} with content template...`);
          
          // Create new page with cover page dimensions
          const newChartPage = finalDoc.addPage([pageWidth, pageHeight]);
          
          // First, add the content page template as background
          const embeddedContentPage = await finalDoc.embedPage(contentPage);
          
          // Scale content page to match cover page dimensions if needed
          const contentScaleX = pageWidth / contentPage.getSize().width;
          const contentScaleY = pageHeight / contentPage.getSize().height;
          const contentScale = Math.min(contentScaleX, contentScaleY);
          
          const contentScaledWidth = contentPage.getSize().width * contentScale;
          const contentScaledHeight = contentPage.getSize().height * contentScale;
          const contentX = (pageWidth - contentScaledWidth) / 2;
          const contentY = (pageHeight - contentScaledHeight) / 2;
          
          newChartPage.drawPage(embeddedContentPage, {
            x: contentX,
            y: contentY,
            width: contentScaledWidth,
            height: contentScaledHeight
          });
          
          // Then, add the chart content on top of the template
          // Calculate scaling to fit chart page to cover page dimensions while maintaining aspect ratio
          const chartScaleX = pageWidth / chartWidth;
          const chartScaleY = pageHeight / chartHeight;
          const chartScale = Math.min(chartScaleX, chartScaleY);
          
          // Calculate position to center the scaled chart page
          const chartScaledWidth = chartWidth * chartScale;
          const chartScaledHeight = chartHeight * chartScale;
          const chartX = (pageWidth - chartScaledWidth) / 2;
          const chartY = (pageHeight - chartScaledHeight) / 2;
          
          console.log(`Adding chart content on top of template for page ${i + 1}`);
          
          // Embed the chart page with some transparency to blend with template
          const embeddedChartPage = await finalDoc.embedPage(chartPage);
          newChartPage.drawPage(embeddedChartPage, {
            x: chartX,
            y: chartY,
            width: chartScaledWidth,
            height: chartScaledHeight,
            opacity: 0.95 // Slight transparency to blend with template
          });
          
          // Add page number at bottom right corner (starting from page 2)
          const pageNumber = i + 2; // Page 1 is cover, so charts start from page 2
          
          // Embed a standard font for page numbers
          const font = await finalDoc.embedFont(PDFLib.StandardFonts.Helvetica);
          
          newChartPage.drawText(`${pageNumber}`, {
            x: pageWidth - 50, // 50 points from right edge
            y: 8, // Moved further down from 15 to 8 points from bottom
            size: 10,
            font: font,
            color: PDFLib.rgb(0.4, 0.4, 0.4) // Gray color
          });
          
          console.log(`Added page number ${pageNumber} to chart page ${i + 1}`);
        }

        console.log("Generating final PDF...");
        
        // 6. Serialize final PDF with compression and trigger download
        const finalBytes = await finalDoc.save({
          compress: true, // Enable compression
          objectStreamsFlate: true // Use flate compression for object streams
        });
        
        // Create download link
        const blob = new Blob([finalBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Research Chart Package.pdf';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log("âœ… Final PDF with content page template and page numbers generated successfully");
        
      } catch (error) {
        console.error("âŒ Error merging PDF with cover:", error);
        
        // Fallback: save charts PDF without cover
        console.log("Falling back to charts-only PDF...");
        const url = URL.createObjectURL(chartPdfBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'selected-charts-no-cover.pdf';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert(`Could not merge with cover page: ${error.message}\nDownloaded charts-only PDF instead.`);
      }
    },

    /**
     * Fetch image through CORS proxy with fallback support
     */
    async fetchImageThroughProxy(chart) {
      const corsConfig = [[cors_config]];
      
      // Determine the original image URL to fetch
      let originalUrl = chart.original_src || chart.src;
      
      // Remove any existing proxy wrapping to get the clean original URL
      if (originalUrl.includes('refini.tv') && !originalUrl.startsWith('https://refini.tv')) {
        // Extract the original refini.tv URL if it's wrapped in a proxy
        const match = originalUrl.match(/refini\.tv\/[^&?]+/);
        if (match) {
          originalUrl = 'https://' + match[0];
        }
      }
      
      console.log(`ðŸ”„ Fetching image: ${originalUrl}`);

      // List of proxy services to try in order
      const proxyServices = [
        {
          name: 'Cloudflare Workers',
          url: 'https://img-cors-proxy.haining-zha.workers.dev',
          format: (proxyUrl, imageUrl) => `${proxyUrl}?url=${encodeURIComponent(imageUrl)}`
        },
        {
          name: 'AllOrigins Raw',
          url: 'https://api.allorigins.win/raw',
          format: (proxyUrl, imageUrl) => `${proxyUrl}?url=${encodeURIComponent(imageUrl)}`
        },
        {
          name: 'CORS Proxy IO',
          url: 'https://corsproxy.io',
          format: (proxyUrl, imageUrl) => `${proxyUrl}/?${encodeURIComponent(imageUrl)}`
        }
      ];

      let lastError = null;

      // Try each proxy service until one works
      for (const proxy of proxyServices) {
        try {
          console.log(`ðŸ”„ Trying ${proxy.name}...`);
          
          const proxyUrl = proxy.format(proxy.url, originalUrl);
          console.log(`Proxy URL: ${proxyUrl}`);
          
          // Create AbortController for timeout handling
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
            console.log(`â° ${proxy.name} request timed out after 15 seconds`);
          }, 15000); // 15 second timeout
          
          const startTime = Date.now();
          
          const response = await fetch(proxyUrl, {
            mode: 'cors',
            cache: 'default',
            signal: controller.signal,
            headers: {
              'Accept': 'image/*,*/*;q=0.8',
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
          });
          
          clearTimeout(timeoutId); // Clear timeout if request completes
          
          const responseTime = Date.now() - startTime;
          console.log(`ðŸ“¡ ${proxy.name} response: ${response.status} in ${responseTime}ms`);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const blob = await response.blob();
          console.log(`ðŸ“¦ ${proxy.name} blob: ${blob.size} bytes, type: ${blob.type}`);
          
          // Validate blob content
          if (blob.size === 0) {
            throw new Error('Received empty response');
          }
          
          // More flexible content type validation - accept any blob that might be an image
          const isValidBlob = blob.size > 0 && (
            blob.type.startsWith('image/') || 
            blob.type === 'application/octet-stream' ||
            blob.type === '' ||
            blob.type === 'text/plain' // Some proxies return this for images
          );
          
          if (!isValidBlob) {
            throw new Error(`Invalid content: ${blob.size} bytes, type: ${blob.type}`);
          }
          
          // Convert blob to image and optimize it
          const objectURL = URL.createObjectURL(blob);
          
          try {
            const optimizedDataURL = await new Promise((resolve, reject) => {
              const img = new Image();
              let timeoutId;
              
              img.onload = () => {
                clearTimeout(timeoutId);
                try {
                  console.log(`ðŸ–¼ï¸ ${proxy.name} image loaded: ${img.naturalWidth}x${img.naturalHeight}`);
                  
                  // Create canvas for optimization
                  const canvas = document.createElement('canvas');
                  const ctx = canvas.getContext('2d');
                  
                  // Use original dimensions for maximum quality
                  canvas.width = img.naturalWidth;
                  canvas.height = img.naturalHeight;
                  
                  // Enable highest quality image smoothing
                  ctx.imageSmoothingEnabled = true;
                  ctx.imageSmoothingQuality = 'high';
                  
                  // Draw image at original size
                  ctx.drawImage(img, 0, 0);
                  
                  // Use PNG for lossless compression
                  const dataURL = canvas.toDataURL('image/png');
                  
                  // Validate the data URL
                  if (dataURL.length < 100) {
                    reject(new Error('Generated image data is too small, possibly corrupt'));
                  } else {
                    resolve(dataURL);
                  }
                } catch (canvasError) {
                  reject(new Error(`Canvas error: ${canvasError.message}`));
                }
              };
              
              img.onerror = () => {
                clearTimeout(timeoutId);
                URL.revokeObjectURL(objectURL);
                reject(new Error('Downloaded content is not a valid image'));
              };
              
              // Set a timeout for image loading
              timeoutId = setTimeout(() => {
                URL.revokeObjectURL(objectURL);
                reject(new Error('Image load timeout'));
              }, 5000);
              
              img.src = objectURL;
            });
            
            URL.revokeObjectURL(objectURL); // Clean up
            
            const totalTime = Date.now() - startTime;
            console.log(`âœ… ${proxy.name} success in ${totalTime}ms total`);
            return optimizedDataURL;
            
          } catch (imageError) {
            URL.revokeObjectURL(objectURL);
            throw new Error(`Image processing failed: ${imageError.message}`);
          }
          
        } catch (error) {
          console.warn(`âŒ ${proxy.name} failed: ${error.message}`);
          lastError = error;
          
          // Add a small delay between attempts to avoid overwhelming servers
          await new Promise(resolve => setTimeout(resolve, 500));
          continue;
        }
      }
      
      // If all proxies failed, try direct fetch as absolute last resort
      try {
        console.log('ðŸ”„ All proxies failed, trying direct fetch as last resort...');
        
        const response = await fetch(originalUrl, {
          mode: 'no-cors', // This won't work for reading the response, but worth trying
          cache: 'default'
        });
        
        console.log(`Direct fetch response status: ${response.status}`);
        // no-cors mode doesn't allow reading the response, so this is mainly for logging
        
      } catch (directError) {
        console.log(`Direct fetch also failed: ${directError.message}`);
      }
      
      // If we get here, all attempts failed
      throw new Error(`All proxy attempts failed. Last error: ${lastError?.message || 'Unknown error'}. Original URL: ${originalUrl}`);
    },
    
    // Allocation data methods
    initializeAllocationData() {
      // Check if we have allocation data
      if (!allocationData || Object.keys(allocationData).length === 0) {
        console.warn('No allocation data available');
        // Set some placeholder dates from 2020-2024
        const dates = [];
        for (let year = 2020; year <= 2024; year++) {
          for (let month = 1; month <= 12; month++) {
            const monthStr = month < 10 ? `0${month}` : `${month}`;
            dates.push(`${year}-${monthStr}-01`);
          }
        }
        
        this.allocationDates = dates;
        this.currentAssets = [
          { name: 'Equities', value: 5 },
          { name: 'Bonds', value: -2 },
          { name: 'Cash', value: 3 }
        ];
        
        // Initialize years for the picker
        this.initializeDatePicker();
        return;
      }
      
      // Extract all unique dates across all tabs
      const allDates = new Set();
      for (const tab in allocationData) {
        if (allocationData[tab] && allocationData[tab].data) {
          allocationData[tab].data.forEach(item => {
            allDates.add(item.date);
          });
        }
      }
      
      // Sort dates
      this.allocationDates = Array.from(allDates).sort();
      
      // Initialize the date picker
      this.initializeDatePicker();
      
      // Create available datasets first
      this.updateAvailableDatasets();
      
      // Update views
      this.updateAllocationView();
      this.initTimeSeriesChart();
    },
    
    /**
     * Initialize the date picker based on available allocation dates
     * Sets up years, initial date values and date ticks for the UI
     */
    initializeDatePicker() {
      // Extract years from allocation dates
      if (this.allocationDates.length > 0) {
        const minDate = this.allocationDates[0];
        const maxDate = this.allocationDates[this.allocationDates.length - 1];
        
        const minYear = parseInt(minDate.substring(0, 4));
        const maxYear = parseInt(maxDate.substring(0, 4));
        
        this.years = [];
        for (let year = minYear; year <= maxYear; year++) {
          this.years.push(year);
        }
        
        // Set initial values
        this.selectedYear = maxYear;
        this.selectedMonth = maxDate.substring(5, 7);
        this.selectedAllocationDate = maxDate;
        
        this.startYear = minYear;
        this.startMonth = minDate.substring(5, 7);
        this.timeSeriesStartDate = minDate;
        
        this.endYear = maxYear;
        this.endMonth = maxDate.substring(5, 7);
        this.timeSeriesEndDate = maxDate;
        
        // Create date ticks (for years)
        this.generateDateTicks();
      }
    },
    
    /**
     * Generate year markers for date visualization
     */
    generateDateTicks() {
      // Generate ticks for the date range slider
      this.dateTicks = [];
      
      if (this.allocationDates.length === 0) return;
      
      const firstDate = this.allocationDates[0];
      const lastDate = this.allocationDates[this.allocationDates.length - 1];
      
      const firstYear = parseInt(firstDate.substring(0, 4));
      const lastYear = parseInt(lastDate.substring(0, 4));
      
      // Add a tick for January of each year
      for (let year = firstYear; year <= lastYear; year++) {
        const date = `${year}-01-01`;
        
        // Only add if it's within our date range
        if (date >= firstDate && date <= lastDate) {
          this.dateTicks.push({
            date: date,
            label: year.toString()
          });
        }
      }
    },
    
    /**
     * Update the selected date for allocation view
     * Combines the selected year and month into a date string
     */
    updateSelectedDate() {
      // Combine selected year and month
      this.selectedAllocationDate = `${this.selectedYear}-${this.selectedMonth}-01`;
      this.updateAllocationView();
    },
    
    /**
     * Update the allocation view based on current tab and date
     * Loads asset values for the selected date from the data
     */
    updateAllocationView() {
      // Get data for the current tab
      if (!allocationData || !allocationData[this.currentAllocationTab]) {
        this.currentAssets = [];
        return;
      }
      
      // Find data for the selected date
      const tabData = allocationData[this.currentAllocationTab].data;
      const dateData = tabData.find(d => d.date === this.selectedAllocationDate);
      
      if (dateData) {
        this.currentAssets = dateData.assets;
      } else {
        // No data for this specific date
        this.currentAssets = [];
      }
    },
    
    /**
     * Initialize the time series chart for historical allocation display
     * Creates a Chart.js line chart on the canvas element
     */
    initTimeSeriesChart() {
      this.$nextTick(() => {
        // If Chart.js is available, create time series chart
        if (window.Chart && this.$refs.timeSeriesChart) {
          if (this.timeSeriesChart) {
            this.timeSeriesChart.destroy();
          }
          
          // Ensure all series are selected by default
          if (this.selectedSeries.length === 0 && this.availableDatasets && this.availableDatasets.length > 0) {
            this.selectedSeries = this.availableDatasets.map(d => d.label);
          }
          
          const ctx = this.$refs.timeSeriesChart.getContext('2d');
          this.createTimeSeriesChart(ctx);
        } else {
          console.warn('Chart.js not available or canvas element not found');
        }
      });
    },
    
    /**
     * Create a time series chart using Chart.js
     * @param {CanvasRenderingContext2D} ctx - Canvas context for drawing the chart
     */
    createTimeSeriesChart(ctx) {
      // Early exit if no series selected
      if (this.selectedSeries.length === 0) {
        // Clear chart if it exists
        if (this.timeSeriesChart) {
          this.timeSeriesChart.destroy();
          this.timeSeriesChart = null;
        }
        
        // Clear the canvas completely
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#6B7280';
        ctx.fillText('No series selected', ctx.canvas.width/2, ctx.canvas.height/2);
        return;
      }
      
      // Filter data between selected dates
      const filteredDates = this.allocationDates.filter(date => {
        const dateStr = date.substring(0, 7); // Get YYYY-MM part
        const startStr = this.timeSeriesStartDate.substring(0, 7);
        const endStr = this.timeSeriesEndDate.substring(0, 7);
        
        // Ensure both start and end months are included (inclusive comparison)
        return dateStr >= startStr && dateStr <= endStr;
      });
      
      if (filteredDates.length === 0) return;
      
      // Filter datasets based on selection
      const datasets = this.availableDatasets.filter(d => 
        this.selectedSeries.includes(d.label)
      );
      
      // Create chart with improved styling
      this.timeSeriesChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: filteredDates.map(date => this.formatDate(date)),
          datasets: datasets.map(dataset => {
            return {
              ...dataset,
              pointBackgroundColor: dataset.borderColor, // Ensure points are filled
              pointRadius: 4,
              pointHoverRadius: 6,
              fill: false,
              tension: 0.1,
              data: filteredDates.map(date => {
                const dateData = allocationData[this.currentAllocationTab].data.find(d => d.date === date);
                if (dateData) {
                  const assetData = dateData.assets.find(a => a.name === dataset.label);
                  return assetData ? assetData.value : null;
                }
                return null;
              })
            };
          })
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              min: -10,
              max: 10,
              ticks: {
                stepSize: 5
              },
              title: {
                display: true,
                text: 'Allocation Target'
              }
            },
            x: {
              ticks: {
                maxRotation: 45, // Angle labels for better readability
                autoSkip: true,
                autoSkipPadding: 10
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(255, 255, 255, 0.9)', // White with transparency
              titleColor: '#111827', // Dark text for title
              bodyColor: '#374151', // Dark text for body
              borderColor: '#E5E7EB',
              borderWidth: 1,
              padding: 10,
              boxPadding: 5,
              usePointStyle: true, // Use point style for legend markers
              boxWidth: 10, // Width of color box
              callbacks: {
                label: function(context) {
                  if (context.raw === null) {
                    return context.dataset.label + ': No data';
                  }
                  return context.dataset.label + ': ' + Number(context.raw).toFixed(1);
                }
              }
            }
          }
        }
      });
    },
    
    /**
     * Update the time series chart with current data
     * Destroys and recreates the chart to ensure clean rendering
     */
    updateTimeSeriesChart() {
      this.$nextTick(() => {
        if (this.$refs.timeSeriesChart) {
          const ctx = this.$refs.timeSeriesChart.getContext('2d');
          
          // Completely destroy existing chart
          if (this.timeSeriesChart) {
            this.timeSeriesChart.destroy();
            this.timeSeriesChart = null;
          }
          
          // Create new chart (which handles empty series properly)
          this.createTimeSeriesChart(ctx);
        }
      });
    },
    
    /**
     * Calculate position for marker on allocation line
     * @param {number} value - The value (-10 to 10) to position
     * @returns {number} - Percentage position on the line (0-100)
     */
    calculateMarkerPosition(value) {
      // All lines use the same scale calculation
      return ((value + 10) / 20) * 100;
    },
    
    /**
     * Format date for display in charts
     * @param {string} dateString - ISO date string (YYYY-MM-DD)
     * @returns {string} - Formatted date (e.g., "Jan 2024")
     */
    formatDate(dateString) {
      // Parse the date manually to avoid timezone issues
      const year = dateString.substring(0, 4);
      const month = parseInt(dateString.substring(5, 7)) - 1; // Convert to 0-based month index
      
      // Use a fixed array of month names to ensure correct display
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return `${monthNames[month]} ${year}`;
    },
    
    /**
     * Update the start date for the time series chart
     */
    updateStartDate() {
      this.timeSeriesStartDate = `${this.startYear}-${this.startMonth}-01`;
      
      // Ensure start date is not after end date
      if (this.timeSeriesStartDate > this.timeSeriesEndDate) {
        this.timeSeriesStartDate = this.timeSeriesEndDate;
        this.startYear = this.endYear;
        this.startMonth = this.endMonth;
      }
      
      this.updateTimeSeriesChart();
    },
    
    /**
     * Update the end date for the time series chart
     */
    updateEndDate() {
      this.timeSeriesEndDate = `${this.endYear}-${this.endMonth}-01`;
      
      // Ensure end date is not before start date
      if (this.timeSeriesEndDate < this.timeSeriesStartDate) {
        this.timeSeriesEndDate = this.timeSeriesStartDate;
        this.endYear = this.startYear;
        this.endMonth = this.startMonth;
      }
      
      this.updateTimeSeriesChart();
    },
    
    /**
     * Update available datasets for the current allocation tab
     * Creates data series with appropriate colors for the chart
     */
    updateAvailableDatasets() {
      if (!allocationData || !allocationData[this.currentAllocationTab]) {
        this.availableDatasets = [];
        return;
      }
      
      const tabData = allocationData[this.currentAllocationTab];
      const assets = tabData.assets || [];
      
      // Professional color palette
      const colorPalette = [
        '#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F', 
        '#EDC948', '#B07AA1', '#FF9DA7', '#9C755F', '#BAB0AC',
        '#1F77B4', '#D62728', '#9467BD', '#8C564B', '#E377C2'
      ];
      
      this.availableDatasets = assets.map((asset, index) => {
        const color = colorPalette[index % colorPalette.length];
        return {
          label: asset,
          borderColor: color,
          backgroundColor: 'white'
        };
      });
      
      // Initialize selectedSeries to all datasets by default
      if (this.selectedSeries.length === 0) {
        this.selectedSeries = this.availableDatasets.map(d => d.label);
      }
    },

    /**
     * Format asset name for display
     * @param {string} assetName - The raw asset name from data
     * @returns {string} - Formatted asset name
     */
    formatAssetName(assetName) {
      if (this.isSubAsset(assetName)) {
        // Special handling for "Other" categories
        if (assetName.includes('Other EU') || assetName.includes('Other EM')) {
          return assetName;
        }
        
        // For sub-assets, extract just the country name if possible
        const nameParts = assetName.split(' - ');
        if (nameParts.length > 1) {
          return nameParts[1]; // Return just the country part
        }
        
        // For country names without the parent - country format
        const europeanParents = ['Europe', 'EU'];
        const emParents = ['EM', 'Emerging'];
        
        for (const parent of europeanParents) {
          if (assetName.startsWith(parent)) {
            return assetName.replace(parent, '').trim();
          }
        }
        
        for (const parent of emParents) {
          if (assetName.startsWith(parent)) {
            return assetName.replace(parent, '').trim();
          }
        }
        
        return assetName;
      }
      return assetName;
    },
    
    /**
     * Determine if an asset is a sub-asset (e.g., country within a region)
     * @param {string} assetName - The asset name to check
     * @returns {boolean} - True if this is a sub-asset
     */
    isSubAsset(assetName) {
      // Check if this is a European country or EM country
      if (this.currentAllocationTab === 'Equities-Region') {
        // Check for specific "Other" categories
        if (assetName.includes('Other EU') || assetName.includes('Other EM')) {
          return true;
        }
        
        // European sub-regions
        if (assetName.includes(' - ') && 
            (assetName.startsWith('Europe') || assetName.startsWith('EM'))) {
          return true;
        }
        
        // Alternative naming patterns
        const europeanCountries = ['Germany', 'France', 'Italy', 'Spain', 'UK', 
                                  'Switzerland', 'Netherlands', 'Belgium', 'Sweden', 
                                  'Denmark', 'Norway', 'Finland', 'Austria', 'Ireland', 
                                  'Portugal', 'Greece'];
                                  
        const emCountries = ['China', 'India', 'Brazil', 'Russia', 'South Africa', 
                            'Mexico', 'Indonesia', 'Turkey', 'Thailand', 'Malaysia', 
                            'Philippines', 'Chile', 'Colombia', 'Peru', 'Egypt',
                            'Korea', 'South Korea', 'Taiwan']; // Added Korea and Taiwan
        
        if (europeanCountries.some(country => assetName.includes(country)) || 
            emCountries.some(country => assetName.includes(country))) {
          return true;
        }
      }
      return false;
    },

    /**
     * Toggle the series dropdown visibility
     */
    toggleSeriesDropdown() {
      this.seriesDropdownOpen = !this.seriesDropdownOpen;
      
      // If opening dropdown, add document click listener to detect outside clicks
      if (this.seriesDropdownOpen) {
        this.$nextTick(() => {
          document.addEventListener('click', this.handleOutsideClick);
        });
      }
    },

    /**
     * Handle clicks outside the dropdown to close it
     * @param {Event} event - The click event
     */
    handleOutsideClick(event) {
      // Get references to dropdown elements
      const dropdown = this.$el.querySelector('.series-dropdown-content');
      const toggle = this.$el.querySelector('.series-dropdown-toggle');
      
      // Check if click is outside both the dropdown and toggle button
      if (dropdown && toggle && 
          !dropdown.contains(event.target) && 
          !toggle.contains(event.target)) {
        this.seriesDropdownOpen = false;
        document.removeEventListener('click', this.handleOutsideClick);
      }
    },

    /**
     * Select all available data series
     */
    selectAllSeries() {
      // Select all available series for the current tab
      this.selectedSeries = [...this.availableDatasets.map(d => d.label)];
      this.updateTimeSeriesChart();
    },

    /**
     * Deselect all data series
     */
    deselectAllSeries() {
      // Deselect all series
      this.selectedSeries = [];
      this.updateTimeSeriesChart();
    },

    runOptimization() {
      if (!this.canOptimize) {
        this.optimizationStatus = 'Please ensure original portfolio weights sum to 100%';
        return;
      }
      
      this.optimizationStatus = 'Running gradient descent optimization...';
      
      // Run gradient descent optimization using external library
      setTimeout(() => {
        try {
          // Determine starting weights based on optimization starting state
          let startingWeights;
          
          if (this.optimizationStartingState === 'optimized') {
            // Check if optimized weights are valid (not all zeros)
            const optimizedSum = Object.values(this.optimizedWeights).reduce((sum, weight) => {
              return sum + (parseFloat(weight) || 0);
            }, 0);
            
            console.log('Optimized weights sum:', optimizedSum, 'Optimized weights:', this.optimizedWeights);
            
            if (Math.abs(optimizedSum - 100) < 0.1) {
              // Use optimized weights if they sum to 100%
              startingWeights = { ...this.optimizedWeights };
              console.log('Using optimized weights as starting point:', startingWeights);
            } else {
              // Fall back to original weights if optimized weights are invalid/zeros
              startingWeights = { ...this.originalWeights };
              console.log('Falling back to original weights:', startingWeights);
            }
          } else {
            // Use original weights
            startingWeights = { ...this.originalWeights };
            console.log('Using original weights as starting point:', startingWeights);
          }
          
          // Create PortfolioOptimizer instance
          const optimizer = new PortfolioOptimizer({
            stepSize: 0.1, // Gradient descent step size
            maxStagnation: 10
          });
          
          // Create metrics calculation function that this component can use
          const calculateMetrics = (weights) => {
            try {
              console.log('Calculating metrics for weights:', weights);
              const { dates, portfolioReturns } = this.getPortfolioReturnsForWeights(weights);
              console.log('Portfolio returns calculated:', portfolioReturns?.length, 'periods');
              
              if (!portfolioReturns || portfolioReturns.length === 0) {
                console.warn('No portfolio returns available for metrics calculation');
                return null;
              }
              
              const metrics = calculateMetricsForReturns(portfolioReturns, 0.02, dates);
              console.log('Calculated metrics:', metrics);
              return metrics;
            } catch (error) {
              console.error('Error in calculateMetrics:', error);
              return null;
            }
          };
          
          // Run optimization
          const result = optimizer.gradientDescentOptimization(
            startingWeights,
            this.optimizationObjective,
            calculateMetrics,
            parseFloat(this.stepSize) // turnover limit
          );
          
          console.log('Optimization result:', result);
          
          if (result.success) {
            console.log('Applying optimized weights:', result.weights);
            // Apply the optimized weights
            Object.keys(result.weights).forEach(asset => {
              this.optimizedWeights[asset] = result.weights[asset];
            });
            
            console.log('Updated optimizedWeights:', this.optimizedWeights);
            
            this.updatePortfolioReturns();
            this.calculatePerformanceMetrics();
            this.updateCumulativeReturnsChart();
            
            this.optimizationStatus = `Optimization completed! Improved ${this.optimizationObjective} from ${result.initialMetric.toFixed(3)} to ${result.finalMetric.toFixed(3)} in ${result.iterations} iterations.`;
          } else {
            console.error('Optimization failed:', result.error);
            this.optimizationStatus = `Optimization failed: ${result.error}`;
          }
        } catch (error) {
          console.error('Optimization error:', error);
          this.optimizationStatus = `Optimization failed: ${error.message}`;
        }
        
        // Clear status after 5 seconds
        setTimeout(() => {
          this.optimizationStatus = null;
        }, 5000);
      }, 100);
    },

    resetOptimization() {
      this.currentStep = 0;
      this.optimizationObjective = 'sharpe';
      this.optimizationStartingState = 'original';
      this.riskTolerance = 5;
      this.timeHorizon = '5';
      
      // Reset constraints
      this.minEquity = 20;
      this.maxEquity = 80;
      this.minBonds = 20;
      this.maxBonds = 60;
      this.minCash = 0;
      this.maxCash = 20;
      this.minAlts = 0;
      this.maxAlts = 30;
      
      // Reset the optimized portfolio (old structure)
      this.optimizedPortfolio = [
        { asset: 'US Equities', weight: 0 },
        { asset: 'International Equities', weight: 0 },
        { asset: 'US Bonds', weight: 0 },
        { asset: 'Cash', weight: 0 },
        { asset: 'Alternatives', weight: 0 }
      ];
      
      // Reset the optimized weights (current structure)
      this.optimizedWeights = {};
      this.optimizedWeightsSum = 0;
      this.availableAssets.forEach(asset => {
        this.$set(this.optimizedWeights, asset, 0);
      });
      
      // Reset performance metrics (old structure)
      this.performanceMetrics.optimizedReturn = 0;
      this.performanceMetrics.optimizedVolatility = 0;
      this.performanceMetrics.optimizedSharpe = 0;
      this.performanceMetrics.optimizedDrawdown = 0;
      
      // Reset the current performance metrics structure
      this.performanceMetrics.optimized = {
        cagr: 0,
        volatility: 0,
        sharpe: 0,
        sortino: 0,
        cvar: 0,
        maxDrawdown: 0
      };
      
      // Reset the chart
      if (this.portfolioPerformanceChart) {
        this.portfolioPerformanceChart.destroy();
        this.portfolioPerformanceChart = null;
      }
      
      // Update the cumulative returns chart if it exists
      if (this.cumulativeReturnsChart) {
        this.updateCumulativeReturnsChart();
      }
    },

    initPerformanceChart() {
      this.$nextTick(() => {
        if (window.Chart && this.$refs.performanceChart) {
          if (this.portfolioPerformanceChart) {
            this.portfolioPerformanceChart.destroy();
          }
          
          const ctx = this.$refs.performanceChart.getContext('2d');
          
          // Get actual portfolio returns data instead of generating random data
          const { dates, originalReturns, optimizedReturns } = this.getFilteredReturnsData();
          
          // If no real data is available, show empty chart with message
          if (dates.length === 0 || !originalReturns || originalReturns.length === 0) {
            // Clear the canvas and show message
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#6B7280';
            ctx.fillText('No return data available for performance chart', ctx.canvas.width/2, ctx.canvas.height/2 - 10);
            ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.fillText('Please ensure portfolio weights are set and return data is loaded', ctx.canvas.width/2, ctx.canvas.height/2 + 15);
            return;
          }
          
          // Use external function to calculate cumulative returns from actual data
          const originalCumulative = calculateCumulativeReturns(originalReturns);
          const optimizedCumulative = calculateCumulativeReturns(optimizedReturns);
          
          // Format dates for display
          const formattedDates = dates.map(date => this.formatDate(date));
          
          // Configure and create chart
          this.portfolioPerformanceChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: formattedDates,
              datasets: [
                {
                  label: 'Original Portfolio',
                  data: originalCumulative,
                  borderColor: '#4F46E5',
                  backgroundColor: 'rgba(79, 70, 229, 0.1)',
                  borderWidth: 2,
                  fill: false,
                  tension: 0.1
                },
                {
                  label: 'Optimized Portfolio',
                  data: optimizedCumulative,
                  borderColor: '#10B981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  borderWidth: 2,
                  fill: false,
                  tension: 0.1
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  ticks: {
                    callback: function(value) {
                      return value.toFixed(2) + '%';
                    }
                  },
                  title: {
                    display: true,
                    text: 'Cumulative Return (%)'
                  }
                },
                x: {
                  ticks: {
                    maxRotation: 45,
                    autoSkip: true,
                    autoSkipPadding: 10
                  }
                }
              },
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false,
                  callbacks: {
                    label: function(context) {
                      return context.dataset.label + ': ' + context.raw.toFixed(2) + '%';
                    }
                  }
                }
              }
            }
          });
        }
      });
    },

    updatePortfolioReturns() {
      // Calculate sums, ensuring we handle string inputs properly
      this.originalWeightsSum = Object.values(this.originalWeights).reduce((a, b) => {
        const val = parseFloat(b) || 0;
        return a + val;
      }, 0);
      
      this.optimizedWeightsSum = Object.values(this.optimizedWeights).reduce((a, b) => {
        const val = parseFloat(b) || 0;
        return a + val;
      }, 0);
      
      // Update chart and metrics whenever weights change
      this.updateCumulativeReturnsChart();
      this.calculatePerformanceMetrics();
    },
    
    formatMetric(value, unit = '') {
      if (value === 0 || value === null || value === undefined) {
        return '-';
      }
      return `${value.toFixed(2)}${unit}`;
    },
    
    formatDifference(optimized, original, unit = '') {
      if (optimized === 0 || original === 0) {
        return '-';
      }
      const difference = optimized - original;
      const sign = difference >= 0 ? '+' : '';
      return `${sign}${difference.toFixed(2)}${unit}`;
    },
    getMetricClass(metric) {
      // Determine if optimized metric is better than original
      const original = this.performanceMetrics.original[metric];
      const optimized = this.performanceMetrics.optimized[metric];
      
      // For metrics where higher is better (cagr, sharpe, sortino)
      if (['cagr', 'sharpe', 'sortino'].includes(metric)) {
        return optimized > original ? 'metric-better' : 'metric-worse';
      }
      // For metrics where lower is better (volatility, cvar, maxDrawdown)
      else if (['volatility', 'cvar', 'maxDrawdown'].includes(metric)) {
        return optimized < original ? 'metric-better' : 'metric-worse';
      }
      
      return '';
    },
    
    // New backtest methods
    initializeBacktestData() {
      // Initialize available assets from returns data
      if (returnsData && returnsData.assets && returnsData.assets.asset_names) {
        this.availableAssets = returnsData.assets.asset_names;
      } else {
        // Fallback to sample assets if no data available
        this.availableAssets = ['US Equities', 'International Equities', 'US Bonds', 'Cash', 'Alternatives'];
      }
      
      // Always initialize ALL weights to 0 when entering the page
      this.originalWeights = {};
      this.optimizedWeights = {};
      
      this.availableAssets.forEach(asset => {
        this.$set(this.originalWeights, asset, 0);
        this.$set(this.optimizedWeights, asset, 0);
      });
      
      // Initialize years for date selectors
      if (returnsData && returnsData.assets && returnsData.assets.dates) {
        const dates = returnsData.assets.dates;
        const years = new Set();
        dates.forEach(date => {
          const year = parseInt(date.substring(0, 4));
          years.add(year);
        });
        this.availableYears = Array.from(years).sort();
        
        // Set initial dates
        if (this.availableYears.length > 0) {
          this.customStartYear = this.availableYears[0];
          this.customEndYear = this.availableYears[this.availableYears.length - 1];
        }
      } else {
        // Fallback years
        this.availableYears = [2020, 2021, 2022, 2023, 2024];
        this.customStartYear = 2020;
        this.customEndYear = 2024;
      }
      
      // Update portfolio sums
      this.updatePortfolioReturns();
    },
    
    selectPresetPeriod(period) {
      this.backtestStartDate = period.start + '-01';
      this.backtestEndDate = period.end + '-01';
      
      // Update the custom selectors to match
      const [startYear, startMonth] = period.start.split('-');
      const [endYear, endMonth] = period.end.split('-');
      
      this.customStartYear = parseInt(startYear);
      this.customStartMonth = startMonth;
      this.customEndYear = parseInt(endYear);
      this.customEndMonth = endMonth;
      
      // Update charts and calculations
      this.updateCumulativeReturnsChart();
      this.calculatePerformanceMetrics();
    },
    
    updateCustomPeriod() {
      this.backtestStartDate = `${this.customStartYear}-${this.customStartMonth}-01`;
      this.backtestEndDate = `${this.customEndYear}-${this.customEndMonth}-01`;
      
      // Update charts and calculations
      this.updateCumulativeReturnsChart();
      this.calculatePerformanceMetrics();
    },
    
    updateCumulativeReturnsChart() {
      this.$nextTick(() => {
        if (window.Chart && this.$refs.cumulativeReturnsChart) {
          if (this.cumulativeReturnsChart) {
            this.cumulativeReturnsChart.destroy();
          }
          
          const ctx = this.$refs.cumulativeReturnsChart.getContext('2d');
          
          // Get filtered data for the selected period
          const { dates, originalReturns, optimizedReturns, benchmarkReturns } = this.getFilteredReturnsData();
          
          // If no data is available, show empty chart with message
          if (dates.length === 0) {
            // Clear the canvas and show message
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#6B7280';
            ctx.fillText('No data available for the selected period and portfolio weights', ctx.canvas.width/2, ctx.canvas.height/2 - 10);
            ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.fillText('Ensure portfolio weights sum to 100% and selected assets have data', ctx.canvas.width/2, ctx.canvas.height/2 + 15);
            return;
          }
          
          // Use external function to calculate cumulative returns
          const originalCumulative = calculateCumulativeReturns(originalReturns);
          const optimizedCumulative = calculateCumulativeReturns(optimizedReturns);
          const allStocksCumulative = calculateCumulativeReturns(benchmarkReturns.allStocks);
          const allBondsCumulative = calculateCumulativeReturns(benchmarkReturns.allBonds);
          const inflationCumulative = calculateCumulativeReturns(benchmarkReturns.inflation);
          
          // Professional color palette
          const colors = {
            allStocks: '#1f77b4',     // Professional blue
            allBonds: '#ff7f0e',      // Professional orange  
            inflation: '#2ca02c',     // Professional green
            original: '#d62728',      // Professional red
            optimized: '#9467bd'      // Professional purple
          };
          
          // Build datasets array based on weight validation
          const datasets = [
            {
              label: 'All Stocks',
              data: allStocksCumulative,
              borderColor: colors.allStocks,
              backgroundColor: colors.allStocks,
              borderWidth: 2,
              pointRadius: 0,
              pointHoverRadius: 4,
              pointBackgroundColor: colors.allStocks,
              pointBorderColor: colors.allStocks,
              fill: false,
              tension: 0.1
            },
            {
              label: 'All Bonds',
              data: allBondsCumulative,
              borderColor: colors.allBonds,
              backgroundColor: colors.allBonds,
              borderWidth: 2,
              pointRadius: 0,
              pointHoverRadius: 4,
              pointBackgroundColor: colors.allBonds,
              pointBorderColor: colors.allBonds,
              fill: false,
              tension: 0.1
            },
            {
              label: 'Inflation',
              data: inflationCumulative,
              borderColor: colors.inflation,
              backgroundColor: colors.inflation,
              borderWidth: 1,
              borderDash: [5, 5],
              pointRadius: 0,
              pointHoverRadius: 4,
              pointBackgroundColor: colors.inflation,
              pointBorderColor: colors.inflation,
              fill: false,
              tension: 0.1
            }
          ];
          
          // Only add Original Portfolio if weights sum to approximately 100%
          if (Math.abs(this.originalWeightsSum - 100) < 0.1) {
            datasets.push({
              label: 'Original Portfolio',
              data: originalCumulative,
              borderColor: colors.original,
              backgroundColor: colors.original,
              borderWidth: 3,
              pointRadius: 0,
              pointHoverRadius: 5,
              pointBackgroundColor: colors.original,
              pointBorderColor: colors.original,
              fill: false,
              tension: 0.1
            });
          }
          
          // Only add Optimized Portfolio if weights sum to approximately 100%
          if (Math.abs(this.optimizedWeightsSum - 100) < 0.1) {
            datasets.push({
              label: 'Optimized Portfolio',
              data: optimizedCumulative,
              borderColor: colors.optimized,
              backgroundColor: colors.optimized,
              borderWidth: 3,
              pointRadius: 0,
              pointHoverRadius: 5,
              pointBackgroundColor: colors.optimized,
              pointBorderColor: colors.optimized,
              fill: false,
              tension: 0.1
            });
          }
          
          this.cumulativeReturnsChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: dates.map(date => this.formatDate(date)),
              datasets: datasets
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  ticks: {
                    callback: function(value) {
                      return value.toFixed(1) + '%';
                    }
                  },
                  title: {
                    display: true,
                    text: 'Cumulative Return (%)'
                  }
                },
                x: {
                  ticks: {
                    maxRotation: 45,
                    autoSkip: true,
                    autoSkipPadding: 10
                  }
                }
              },
                              plugins: {
                  legend: {
                    display: true,
                    position: 'bottom',
                    align: 'center',
                    labels: {
                      usePointStyle: true,
                      pointStyle: 'circle',
                      padding: 15,
                      font: {
                        size: 12,
                        family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                      },
                      color: '#374151',
                      generateLabels: function(chart) {
                        const original = Chart.defaults.plugins.legend.labels.generateLabels;
                        const labels = original.call(this, chart);
                        
                        labels.forEach(label => {
                          label.pointStyle = 'circle';
                          label.pointStyleWidth = 10;
                          label.pointStyleHeight = 10;
                        });
                        
                        return labels;
                      }
                    }
                  },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                    titleColor: '#111827',
                    bodyColor: '#374151',
                    borderColor: '#E5E7EB',
                    borderWidth: 1,
                    padding: 10,
                    boxPadding: 5,
                    usePointStyle: true,
                    pointStyle: 'circle',
                    boxWidth: 8,
                    boxHeight: 8,
                    callbacks: {
                      label: function(context) {
                        if (context.raw === null) {
                          return context.dataset.label + ': No data';
                        }
                        return context.dataset.label + ': ' + context.raw.toFixed(2) + '%';
                      }
                    }
                  }
              }
            }
          });
        }
      });
    },
    
    getFilteredReturnsData() {
      // Use real data from returnsData if available
      if (!returnsData || !returnsData.assets || !returnsData.reference) {
        console.warn('Returns data not available, using sample data');
        return this.getSampleReturnsData();
      }
      
      const startDateStr = this.backtestStartDate || '2020-01-01';
      const endDateStr = this.backtestEndDate || '2024-12-01';
      
      // First, filter by user-specified date range
      const dateFilteredIndices = [];
      const dateFilteredDates = [];
      
      if (returnsData.assets.date_index) {
        // Fast filtering using date index
        returnsData.assets.dates.forEach((date, index) => {
          if (date >= startDateStr && date <= endDateStr) {
            dateFilteredIndices.push(index);
            dateFilteredDates.push(date);
          }
        });
      } else {
        // Fallback to original method
        returnsData.assets.dates.forEach((date, index) => {
          if (date >= startDateStr && date <= endDateStr) {
            dateFilteredIndices.push(index);
            dateFilteredDates.push(date);
          }
        });
      }
      
      if (dateFilteredDates.length === 0) {
        console.warn('No data found for selected date range, using sample data');
        return this.getSampleReturnsData();
      }
      
      // Identify all active assets (those with non-zero weights) from both portfolios
      const allActiveAssets = new Set();
      
      // Add assets from original portfolio
      Object.keys(this.originalWeights).forEach(asset => {
        const weight = parseFloat(this.originalWeights[asset] || 0);
        if (weight > 0 && returnsData.assets.assets[asset]) {
          allActiveAssets.add(asset);
        }
      });
      
      // Add assets from optimized portfolio
      Object.keys(this.optimizedWeights).forEach(asset => {
        const weight = parseFloat(this.optimizedWeights[asset] || 0);
        if (weight > 0 && returnsData.assets.assets[asset]) {
          allActiveAssets.add(asset);
        }
      });
      
      // Filter to only include dates where ALL active assets have data
      const finalIndices = [];
      const finalDates = [];
      
      dateFilteredIndices.forEach((index, i) => {
        let allAssetsHaveData = true;
        
        // Check if all active assets have data for this date
        for (const asset of allActiveAssets) {
          const assetReturn = returnsData.assets.assets[asset][index];
          if (assetReturn === undefined || assetReturn === null) {
            allAssetsHaveData = false;
            break;
          }
        }
        
        if (allAssetsHaveData) {
          finalIndices.push(index);
          finalDates.push(dateFilteredDates[i]);
        }
      });
      
      if (finalDates.length === 0) {
        console.warn('No periods found where all assets have complete data, using sample data');
        return this.getSampleReturnsData();
      }
      
      // Log the data availability info
      console.log(`Portfolio analysis period: ${finalDates[0]} to ${finalDates[finalDates.length - 1]}`);
      console.log(`Total periods with complete data: ${finalDates.length} out of ${dateFilteredDates.length} requested`);
      if (allActiveAssets.size > 0) {
        console.log(`Active assets requiring data: ${Array.from(allActiveAssets).join(', ')}`);
      }
      
      // Calculate portfolio returns based on weights (now with guaranteed complete data)
      const originalReturns = calculatePortfolioReturns(this.originalWeights, returnsData.assets.assets, finalIndices);
      const optimizedReturns = calculatePortfolioReturns(this.optimizedWeights, returnsData.assets.assets, finalIndices);
      
      // Further filter to only include periods where at least one portfolio has valid weights
      const hasOriginalWeights = Math.abs(this.originalWeightsSum - 100) < 0.1;
      const hasOptimizedWeights = Math.abs(this.optimizedWeightsSum - 100) < 0.1;
      
      // If neither portfolio has valid weights, we don't want to show any periods
      if (!hasOriginalWeights && !hasOptimizedWeights && finalDates.length > 0) {
        console.log('No portfolios have valid weights (sum to 100%), showing empty chart');
        return { 
          dates: [], 
          originalReturns: [], 
          optimizedReturns: [], 
          benchmarkReturns: { allStocks: [], allBonds: [], inflation: [] }
        };
      }
      
      // Get benchmark returns from reference series
      const benchmarkReturns = {
        allStocks: this.getBenchmarkReturns(finalIndices, 'World Equity') || this.getBenchmarkReturns(finalIndices, 'MSCI World') || this.getBenchmarkReturns(finalIndices, 'Equity') || [],
        allBonds: this.getBenchmarkReturns(finalIndices, 'Canadian Bonds') || this.getBenchmarkReturns(finalIndices, 'US Bond') || this.getBenchmarkReturns(finalIndices, 'Bond') || this.getBenchmarkReturns(finalIndices, 'Bonds') || [],
        inflation: this.getBenchmarkReturns(finalIndices, 'Inflation') || finalDates.map(() => 0.2)
      };
      
      return { dates: finalDates, originalReturns, optimizedReturns, benchmarkReturns };
    },
    
    getSampleReturnsData() {
      // Fallback sample data when real data is not available
      const dates = [];
      const originalReturns = [];
      const optimizedReturns = [];
      
      const startDate = new Date(this.backtestStartDate || '2020-01-01');
      const endDate = new Date(this.backtestEndDate || '2024-12-01');
      
      let currentDate = new Date(startDate);
      while (currentDate <= endDate) {
        dates.push(currentDate.toISOString().substring(0, 10));
        originalReturns.push((Math.random() - 0.5) * 6);
        optimizedReturns.push((Math.random() - 0.5) * 5);
        currentDate.setMonth(currentDate.getMonth() + 1);
      }
      
      const benchmarkReturns = {
        allStocks: originalReturns.map(r => r * 1.2),
        allBonds: originalReturns.map(r => r * 0.5),
        inflation: dates.map(() => 0.2)
      };
      
      return { dates, originalReturns, optimizedReturns, benchmarkReturns };
    },
    

    
    getBenchmarkReturns(indices, benchmarkName) {
      // Get benchmark returns from both assets and reference series
      let benchmarkKey = null;
      let benchmarkData = null;
      let sourceLocation = null;
      
      // First search in reference series
      if (returnsData.reference && returnsData.reference.assets) {
        const referenceKeys = Object.keys(returnsData.reference.assets);
        console.log('Looking for benchmark:', benchmarkName, 'in reference series. Available keys:', referenceKeys);
        
        benchmarkKey = this.findBenchmarkKey(referenceKeys, benchmarkName);
        if (benchmarkKey) {
          benchmarkData = returnsData.reference.assets[benchmarkKey];
          sourceLocation = 'reference';
        }
      }
      
      // If not found in reference, search in assets series
      if (!benchmarkKey && returnsData.assets && returnsData.assets.assets) {
        const assetKeys = Object.keys(returnsData.assets.assets);
        console.log('Looking for benchmark:', benchmarkName, 'in assets series. Available keys:', assetKeys);
        
        benchmarkKey = this.findBenchmarkKey(assetKeys, benchmarkName);
        if (benchmarkKey) {
          benchmarkData = returnsData.assets.assets[benchmarkKey];
          sourceLocation = 'assets';
        }
      }
      
      if (!benchmarkKey) {
        console.warn('No benchmark found for:', benchmarkName);
        return null;
      }
      
      console.log('Found benchmark key:', benchmarkKey, 'for search term:', benchmarkName, 'in', sourceLocation, 'series');
      return indices.map(index => {
        const value = benchmarkData[index];
        return value !== null && value !== undefined ? value : 0;
      });
    },
    
    findBenchmarkKey(keys, benchmarkName) {
      // Helper function to find benchmark key with comprehensive matching
      let benchmarkKey = keys.find(key => key === benchmarkName) ||
                         keys.find(key => key.toLowerCase() === benchmarkName.toLowerCase()) ||
                         keys.find(key => key.toLowerCase().includes(benchmarkName.toLowerCase())) ||
                         keys.find(key => benchmarkName.toLowerCase().includes(key.toLowerCase()));
      
      // Additional specific matching for common bond names
      if (!benchmarkKey && benchmarkName.toLowerCase().includes('bond')) {
        benchmarkKey = keys.find(key => 
          key.toLowerCase().includes('bond') || 
          key.toLowerCase().includes('treasury') ||
          key.toLowerCase().includes('govt') ||
          key.toLowerCase().includes('government')
        );
      }
      
      return benchmarkKey;
    },
    
    
    calculatePerformanceMetrics() {
      // Calculate actual performance metrics based on portfolio weights and selected time period
      const { dates, originalReturns, optimizedReturns } = this.getFilteredReturnsData();
      
      if (dates.length === 0) {
        // Fallback to static values if no data
        this.performanceMetrics.original = { cagr: 0, volatility: 0, sharpe: 0, sortino: 0, cvar: 0, maxDrawdown: 0 };
        this.performanceMetrics.optimized = { cagr: 0, volatility: 0, sharpe: 0, sortino: 0, cvar: 0, maxDrawdown: 0 };
        return;
      }
      
      // Calculate metrics for original portfolio
      this.performanceMetrics.original = this.calculateMetricsForReturns(originalReturns);
      
      // Calculate metrics for optimized portfolio (if it has valid weights)
      if (Math.abs(this.optimizedWeightsSum - 100) < 0.1) {
        this.performanceMetrics.optimized = this.calculateMetricsForReturns(optimizedReturns);
      } else {
        this.performanceMetrics.optimized = { cagr: 0, volatility: 0, sharpe: 0, sortino: 0, cvar: 0, maxDrawdown: 0 };
      }
    },
    
    calculateMetricsForReturns(returns) {
      if (!returns || returns.length === 0) {
        return { cagr: 0, volatility: 0, sharpe: 0, sortino: 0, cvar: 0, maxDrawdown: 0 };
      }
      
      // Use external library function with proper frequency detection
      // Get dates for frequency detection from filtered data
      const { dates } = this.getFilteredReturnsData();
      
      // Call external library function with enhanced calculations
      return calculateMetricsForReturns(returns, 0.02, dates);
    },


    initPerformanceChart() {
      this.$nextTick(() => {
        if (window.Chart && this.$refs.performanceChart) {
          if (this.portfolioPerformanceChart) {
            this.portfolioPerformanceChart.destroy();
          }
          
          const ctx = this.$refs.performanceChart.getContext('2d');
          
          // Get actual portfolio returns data instead of generating random data
          const { dates, originalReturns, optimizedReturns } = this.getFilteredReturnsData();
          
          // If no real data is available, show empty chart with message
          if (dates.length === 0 || !originalReturns || originalReturns.length === 0) {
            // Clear the canvas and show message
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#6B7280';
            ctx.fillText('No return data available for performance chart', ctx.canvas.width/2, ctx.canvas.height/2 - 10);
            ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.fillText('Please ensure portfolio weights are set and return data is loaded', ctx.canvas.width/2, ctx.canvas.height/2 + 15);
            return;
          }
          
          // Use external function to calculate cumulative returns from actual data
          const originalCumulative = calculateCumulativeReturns(originalReturns);
          const optimizedCumulative = calculateCumulativeReturns(optimizedReturns);
          
          // Format dates for display
          const formattedDates = dates.map(date => this.formatDate(date));
          
          // Configure and create chart
          this.portfolioPerformanceChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: formattedDates,
              datasets: [
                {
                  label: 'Original Portfolio',
                  data: originalCumulative,
                  borderColor: '#4F46E5',
                  backgroundColor: 'rgba(79, 70, 229, 0.1)',
                  borderWidth: 2,
                  fill: false,
                  tension: 0.1
                },
                {
                  label: 'Optimized Portfolio',
                  data: optimizedCumulative,
                  borderColor: '#10B981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  borderWidth: 2,
                  fill: false,
                  tension: 0.1
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  ticks: {
                    callback: function(value) {
                      return value.toFixed(2) + '%';
                    }
                  },
                  title: {
                    display: true,
                    text: 'Cumulative Return (%)'
                  }
                },
                x: {
                  ticks: {
                    maxRotation: 45,
                    autoSkip: true,
                    autoSkipPadding: 10
                  }
                }
              },
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false,
                  callbacks: {
                    label: function(context) {
                      return context.dataset.label + ': ' + context.raw.toFixed(2) + '%';
                    }
                  }
                }
              }
            }
          });
        }
      });
    },

    /**
     * Get portfolio returns for specific weights - used by optimization
     */
    getPortfolioReturnsForWeights(weights) {
      const { dates, originalReturns } = this.getFilteredReturnsData();
      
      
      if (!returnsData || !returnsData.assets || dates.length === 0) {
        return { dates: [], portfolioReturns: [] };
      }
      
      // Calculate portfolio returns using the same logic as existing method
      const indices = dates.map(date => returnsData.assets.dates.indexOf(date)).filter(i => i !== -1);
      const portfolioReturns = calculatePortfolioReturns(weights, returnsData.assets.assets, indices);
      
      return { dates, portfolioReturns };
    },


  },
  watch: {
    selectedSeries: {
      handler(newValue) {
        // Just update the boolean status
        this.allSeriesSelected = newValue.length === this.availableDatasets.length;
        
        // Always update the chart, even when no series are selected
        this.updateTimeSeriesChart();
      },
      deep: true
    },
    currentAllocationTab: {
      handler(newTab) {
        // Update the available datasets for the new tab
        this.updateAvailableDatasets();
        
        // Reset series selection to all available for this tab
        this.selectedSeries = [...this.availableDatasets.map(d => d.label)];
        
        // Update the chart and allocation view
        this.updateAllocationView();
        this.updateTimeSeriesChart();
      }
    }
  },
  // Initialize the performance chart when switching to the Backtest tab
  currentTab(newTab) {
    if (newTab === 'Backtest') {
      this.$nextTick(() => {
        this.initPerformanceChart();
      });
    }
  }
});
</script>
</body>
</html>
